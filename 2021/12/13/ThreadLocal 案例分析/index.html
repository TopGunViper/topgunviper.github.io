<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ThreadLocal 案例分析 - Hexo</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Hexo"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="目录 123456789101112131. ThreadLocal简介    1.1 ThreadLocal基础        1.1.1 ThreadLocal和Thread的关系        1.1.2 变量的生命周期    1.2 可继承的ThreadLocal2. ThreadLocal的应用案例    2.1 解决并发问题        2.1.1 java.lang.ThreadL"><meta property="og:type" content="blog"><meta property="og:title" content="ThreadLocal 案例分析"><meta property="og:url" content="https://topgunviper.github.io/2021/12/13/ThreadLocal%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="目录 123456789101112131. ThreadLocal简介    1.1 ThreadLocal基础        1.1.1 ThreadLocal和Thread的关系        1.1.2 变量的生命周期    1.2 可继承的ThreadLocal2. ThreadLocal的应用案例    2.1 解决并发问题        2.1.1 java.lang.ThreadL"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><meta property="article:published_time" content="2021-12-13T03:18:46.954Z"><meta property="article:modified_time" content="2021-12-13T08:49:23.064Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="ThreadLocal"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://topgunviper.github.io/2021/12/13/ThreadLocal%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"},"headline":"ThreadLocal 案例分析","image":[],"datePublished":"2021-12-13T03:18:46.954Z","dateModified":"2021-12-13T08:49:23.064Z","author":{"@type":"Person","name":"John Doe"},"publisher":{"@type":"Organization","name":"Hexo","logo":{"@type":"ImageObject","url":"https://topgunviper.github.io/img/logo.svg"}},"description":"目录 123456789101112131. ThreadLocal简介    1.1 ThreadLocal基础        1.1.1 ThreadLocal和Thread的关系        1.1.2 变量的生命周期    1.2 可继承的ThreadLocal2. ThreadLocal的应用案例    2.1 解决并发问题        2.1.1 java.lang.ThreadL"}</script><link rel="canonical" href="https://topgunviper.github.io/2021/12/13/ThreadLocal%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-13T03:18:46.954Z" title="12/13/2021, 11:18:46 AM">2021-12-13</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a><span> / </span><a class="link-muted" href="/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="level-item">24 分钟读完 (大约3658个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">ThreadLocal 案例分析</h1><div class="content"><p>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. ThreadLocal简介</span><br><span class="line">    1.1 ThreadLocal基础</span><br><span class="line">        1.1.1 ThreadLocal和Thread的关系</span><br><span class="line">        1.1.2 变量的生命周期</span><br><span class="line">    1.2 可继承的ThreadLocal</span><br><span class="line">2. ThreadLocal的应用案例</span><br><span class="line">    2.1 解决并发问题</span><br><span class="line">        2.1.1 java.lang.ThreadLocalRandom</span><br><span class="line">        2.1.2 HDFS中的Statistics：实现高并发下的统计功能</span><br><span class="line">    2.2 解决数据存储问题</span><br><span class="line">        2.2.1 Struts2的ActionContext设计原理</span><br><span class="line">        2.2.2 Spring中thread scope Bean</span><br><span class="line">3. 总结</span><br></pre></td></tr></table></figure>
<h2 id="1-ThreadLocal简介"><a href="#1-ThreadLocal简介" class="headerlink" title="1. ThreadLocal简介"></a>1. ThreadLocal简介</h2><blockquote>
<p>这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。</p>
</blockquote>
<h3 id="1-1-ThreadLocal基础"><a href="#1-1-ThreadLocal基础" class="headerlink" title="1.1 ThreadLocal基础"></a>1.1 ThreadLocal基础</h3><h6 id="为什么需要ThreadLocal"><a href="#为什么需要ThreadLocal" class="headerlink" title="为什么需要ThreadLocal"></a>为什么需要ThreadLocal</h6><p>要理解为什么需要ThreadLocal就不得不从<strong>线程安全</strong>问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于<strong>如何平衡高性能和数据一致性</strong>。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。</p>
<blockquote>
<p>所谓的<strong>一致性</strong>，就是关联数据之间的逻辑关系是否正确和完整。</p>
</blockquote>
<p>通过下面示例对数据一致性问题进行说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalDemo &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		int nThreads = 10;</span><br><span class="line">		final Counter counter = new Counter();</span><br><span class="line">		</span><br><span class="line">		ExecutorService exec = Executors.newFixedThreadPool(nThreads);</span><br><span class="line">		final CountDownLatch latch = new CountDownLatch(nThreads);</span><br><span class="line">		</span><br><span class="line">		for(int i = 0; i &lt; nThreads; i++)&#123;</span><br><span class="line">			exec.submit(new Runnable()&#123;</span><br><span class="line">				public void run()&#123;</span><br><span class="line">					for(int i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">						counter.increase();</span><br><span class="line">					&#125;</span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		latch.await();</span><br><span class="line">		System.out.println(&quot;Expected:&quot; + nThreads * 10000 + &quot;,Actual:&quot; + counter.count);</span><br><span class="line">	&#125;</span><br><span class="line">	static class Counter&#123;</span><br><span class="line">		int count = 0;</span><br><span class="line">		</span><br><span class="line">		public void  increase()&#123;</span><br><span class="line">			this.count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Expected:100000,Actual:71851</p>
</blockquote>
<p>可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是<strong>加锁</strong>，本质是<strong>并发访问</strong>到<strong>串行访问</strong>的改变。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Counter&#123;</span><br><span class="line">	int count = 0;</span><br><span class="line">	</span><br><span class="line">	public synchronized void  increase()&#123;</span><br><span class="line">		this.count++;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>Expected:100000,Actual:100000</p>
</blockquote>
<p>第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用<strong>synchronized</strong>修饰过后，<strong>串行访问</strong>时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？</p>
<blockquote>
<p>让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。</p>
</blockquote>
<h4 id="1-1-1-ThreadLocal和Thread的联系"><a href="#1-1-1-ThreadLocal和Thread的联系" class="headerlink" title="1.1.1 ThreadLocal和Thread的联系"></a>1.1.1 ThreadLocal和Thread的联系</h4><p>在上面提到了<strong>数据副本</strong>,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line">    </span><br><span class="line">    //。。。</span><br><span class="line">    </span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class="line">    </span><br><span class="line">    //。。。    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：<strong>ThreadLocalMap的key和value该如何设计呢？</strong></p>
<p>从API角度来说，<strong>ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口</strong>，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的<strong>key</strong>就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    private static AtomicInteger nextHashCode =</span><br><span class="line">        new AtomicInteger();</span><br><span class="line"></span><br><span class="line">    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class="line"></span><br><span class="line">    private static int nextHashCode() &#123;</span><br><span class="line">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">    //。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量副本</strong>的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下：</p>
<ol>
<li><p>get()操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();//获取当前Thread对象引用</span><br><span class="line">    ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null)</span><br><span class="line">            return (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li>
<li><p>set操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。</p>
</li>
<li><p>remove操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    if (m != null)</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-变量的生命周期"><a href="#1-1-2-变量的生命周期" class="headerlink" title="1.1.2 变量的生命周期"></a>1.1.2 变量的生命周期</h4><p>这里所的<strong>变量</strong>指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期:</p>
</li>
<li><p>Init<br>第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Service<br>只要线程活着且ThreadLocal可访问即处于Service阶段。</p>
</li>
<li><p>Destroy<br>由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。</p>
</li>
</ol>
<blockquote>
<p>ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员<br>变量。所以其生命周期当然也就和该类一致。</p>
</blockquote>
<h3 id="1-2-可继承的ThreadLocal"><a href="#1-2-可继承的ThreadLocal" class="headerlink" title="1.2 可继承的ThreadLocal"></a>1.2 可继承的ThreadLocal</h3><p>首先看个实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static class Context &#123;</span><br><span class="line"></span><br><span class="line">	private static final ThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT1 = new ThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class="line">		protected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class="line">			return new HashMap&lt;String,String&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	private static final InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT2 = new InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class="line">		protected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class="line">			return new HashMap&lt;String,String&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;		</span><br><span class="line">	public static HashMap&lt;String,String&gt; getContext1() &#123;</span><br><span class="line">		return CONTEXT1.get();</span><br><span class="line">	&#125;</span><br><span class="line">	public static HashMap&lt;String,String&gt; getContext2() &#123;</span><br><span class="line">		return CONTEXT2.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	Context.getContext1().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class="line">	Context.getContext2().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class="line">	Thread thread = new Thread(new Runnable()&#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			System.out.println(&quot;name:&quot; + Context.getContext1().get(&quot;name&quot;));</span><br><span class="line">			System.out.println(&quot;name:&quot; + Context.getContext2().get(&quot;name&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>name:null</p>
</blockquote>
<blockquote>
<p>name:wqx</p>
</blockquote>
<p>字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程</span><br><span class="line">if (parent.inheritableThreadLocals != null)</span><br><span class="line">    this.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>

<h2 id="2-ThreadLocal的应用案例"><a href="#2-ThreadLocal的应用案例" class="headerlink" title="2. ThreadLocal的应用案例"></a>2. ThreadLocal的应用案例</h2><h3 id="2-1-解决并发问题"><a href="#2-1-解决并发问题" class="headerlink" title="2.1 解决并发问题"></a>2.1 解决并发问题</h3><h4 id="2-1-1-java-lang-ThreadLocalRandom"><a href="#2-1-1-java-lang-ThreadLocalRandom" class="headerlink" title="2.1.1 java.lang.ThreadLocalRandom"></a>2.1.1 java.lang.ThreadLocalRandom</h4><p>在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalRandom extends Random &#123;</span><br><span class="line">    </span><br><span class="line">    //。。。</span><br><span class="line">    </span><br><span class="line">    private static final ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class="line">        new ThreadLocal&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class="line">            protected ThreadLocalRandom initialValue() &#123;</span><br><span class="line">                return new ThreadLocalRandom();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    //。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。</p>
</blockquote>
<h4 id="2-1-2-HDFS中的Statistics：实现高并发下的统计功能"><a href="#2-1-2-HDFS中的Statistics：实现高并发下的统计功能" class="headerlink" title="2.1.2 HDFS中的Statistics：实现高并发下的统计功能"></a>2.1.2 HDFS中的Statistics：实现高并发下的统计功能</h4><p>Hadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？</p>
<blockquote>
<p>方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！</p>
</blockquote>
<blockquote>
<p>方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储<strong>统计数据</strong>的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到<strong>写多读少</strong>的事实，ThreadLocal方案是可以接受的。</p>
</blockquote>
<p>下面是Statistics对象的部分实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static final class Statistics &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Statistics data.</span><br><span class="line">     * /</span><br><span class="line">    public static class StatisticsData &#123;</span><br><span class="line">      volatile long bytesRead;</span><br><span class="line">      volatile long bytesWritten;</span><br><span class="line">      volatile int readOps;</span><br><span class="line">      volatile int largeReadOps;</span><br><span class="line">      volatile int writeOps;</span><br><span class="line">      //。。。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //allData保存的是所有线程中StatisticsData对象的引用</span><br><span class="line">    private final Set&lt;StatisticsDataReference&gt; allData;</span><br><span class="line">    </span><br><span class="line">    //ThreadLocal变量</span><br><span class="line">    private final ThreadLocal&lt;StatisticsData&gt; threadData;</span><br><span class="line">    </span><br><span class="line">    public void incrementBytesWritten(long newBytes) &#123;</span><br><span class="line">      getThreadStatistics().bytesWritten += newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public StatisticsData getThreadStatistics() &#123;</span><br><span class="line">      StatisticsData data = threadData.get();</span><br><span class="line">      if (data == null) &#123;   //第一次统计操作时需要进行初始化，并与allData进行关联</span><br><span class="line">        data = new StatisticsData();</span><br><span class="line">        threadData.set(data);</span><br><span class="line">        StatisticsDataReference ref =</span><br><span class="line">            new StatisticsDataReference(data, Thread.currentThread());</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">          allData.add(ref);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return data;</span><br><span class="line">    &#125;    </span><br><span class="line">    //。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DistributedFileSystem extends FileSystem &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean delete(Path f, final boolean recursive) throws IOException &#123;</span><br><span class="line">    statistics.incrementWriteOps(1);</span><br><span class="line">    // 。。。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public long getBytesWritten() &#123;</span><br><span class="line">  return visitAll(new StatisticsAggregator&lt;Long&gt;() &#123;</span><br><span class="line">    private long bytesWritten = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void accept(StatisticsData data) &#123;</span><br><span class="line">      bytesWritten += data.bytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long aggregate() &#123;</span><br><span class="line">      return bytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//加锁处理，保证统计数据的正确性</span><br><span class="line">private synchronized &lt;T&gt; T visitAll(StatisticsAggregator&lt;T&gt; visitor) &#123;</span><br><span class="line">  visitor.accept(rootData);</span><br><span class="line">  for (StatisticsDataReference ref: allData) &#123;</span><br><span class="line">    StatisticsData data = ref.getData();</span><br><span class="line">    visitor.accept(data);</span><br><span class="line">  &#125;</span><br><span class="line">  return visitor.aggregate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！</p>
<h3 id="2-2-解决数据存储问题"><a href="#2-2-解决数据存储问题" class="headerlink" title="2.2 解决数据存储问题"></a>2.2 解决数据存储问题</h3><h4 id="2-2-1-Struts2的ActionContext设计原理"><a href="#2-2-1-Struts2的ActionContext设计原理" class="headerlink" title="2.2.1 Struts2的ActionContext设计原理"></a>2.2.1 Struts2的ActionContext设计原理</h4><p>Struts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：<strong>Action中的每个方法的请求参数怎么获得的</strong>?<strong>处理结果又是如何返回的</strong>?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。</p>
<blockquote>
<p>Struts2的<strong>最大亮点也许就是对数据流和控制流的解耦</strong>。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。</p>
</blockquote>
<p>首先看下Struts2中几个主要组件的示意图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Struts2组件示意图"></p>
<p>ActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的<strong>请求的生命周期</strong>可以泛指<strong>处理请求的线程的生命周期</strong>。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ActionContext implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    //。。。</span><br><span class="line">    </span><br><span class="line">    static ThreadLocal&lt;ActionContext&gt; actionContext = new ThreadLocal&lt;ActionContext&gt;();</span><br><span class="line">    </span><br><span class="line">    private Map&lt;String, Object&gt; context;</span><br><span class="line"></span><br><span class="line">    public ActionContext(Map&lt;String, Object&gt; context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static ActionContext getContext() &#123;</span><br><span class="line">        return actionContext.get();</span><br><span class="line">    &#125;</span><br><span class="line">    public Map&lt;String, Object&gt; getContextMap() &#123;</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    //。。。</span><br></pre></td></tr></table></figure>
<p>ActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一<strong>解耦思路</strong>值得好好学习。Another brilliant idea！</p>
<h4 id="2-2-1-Spring中thread-scope-Bean"><a href="#2-2-1-Spring中thread-scope-Bean" class="headerlink" title="2.2.1 Spring中thread scope Bean"></a>2.2.1 Spring中thread scope Bean</h4><p>在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容<br>易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleThreadScope implements Scope &#123;</span><br><span class="line"></span><br><span class="line">	private final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope =</span><br><span class="line">			new NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt;(&quot;SimpleThreadScope&quot;) &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected Map&lt;String, Object&gt; initialValue() &#123;</span><br><span class="line">					return new HashMap&lt;String, Object&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; scope = this.threadScope.get();</span><br><span class="line">		Object object = scope.get(name);</span><br><span class="line">		if (object == null) &#123;</span><br><span class="line">			object = objectFactory.getObject();</span><br><span class="line">			scope.put(name, object);</span><br><span class="line">		&#125;</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种<strong>以空间换时间的思路</strong>，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/ThreadLocal/">ThreadLocal</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/12/13/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"><span class="level-item">Web开发中的乱码问题</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "95edf554b4fc0e4f3fcca250e78d2e1e",
            repo: "HexoComment",
            owner: "TopGunViper",
            clientID: "cc5403d1f79e4415d036",
            clientSecret: "11055ac2913fad30908940f9a797899f4dbdd73f",
            admin: ["TopGunViper"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="TopGunViper"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">TopGunViper</p><p class="is-size-6 is-block">Thinking and Practicing</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TopGunViper" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TopGunViper"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-13T03:18:46.954Z">2021-12-13</time></p><p class="title"><a href="/2021/12/13/ThreadLocal%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">ThreadLocal 案例分析</a></p><p class="categories"><a href="/categories/Java/">Java</a> / <a href="/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-12-13T03:18:46.953Z">2021-12-13</time></p><p class="title"><a href="/2021/12/13/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/">Web开发中的乱码问题</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">源码分析</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ThreadLocal/"><span class="tag">ThreadLocal</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-ThreadLocal简介"><span class="level-left"><span class="level-item">1. ThreadLocal简介</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-ThreadLocal基础"><span class="level-left"><span class="level-item">1.1 ThreadLocal基础</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-ThreadLocal和Thread的联系"><span class="level-left"><span class="level-item">1.1.1 ThreadLocal和Thread的联系</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-变量的生命周期"><span class="level-left"><span class="level-item">1.1.2 变量的生命周期</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-可继承的ThreadLocal"><span class="level-left"><span class="level-item">1.2 可继承的ThreadLocal</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-ThreadLocal的应用案例"><span class="level-left"><span class="level-item">2. ThreadLocal的应用案例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-解决并发问题"><span class="level-left"><span class="level-item">2.1 解决并发问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-java-lang-ThreadLocalRandom"><span class="level-left"><span class="level-item">2.1.1 java.lang.ThreadLocalRandom</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-HDFS中的Statistics：实现高并发下的统计功能"><span class="level-left"><span class="level-item">2.1.2 HDFS中的Statistics：实现高并发下的统计功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-解决数据存储问题"><span class="level-left"><span class="level-item">2.2 解决数据存储问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-Struts2的ActionContext设计原理"><span class="level-left"><span class="level-item">2.2.1 Struts2的ActionContext设计原理</span></span></a></li><li><a class="level is-mobile" href="#2-2-1-Spring中thread-scope-Bean"><span class="level-left"><span class="level-item">2.2.1 Spring中thread scope Bean</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#3-总结"><span class="level-left"><span class="level-item">3. 总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="is-size-7"><span>&copy; 2021 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>