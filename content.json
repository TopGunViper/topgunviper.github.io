{"pages":[],"posts":[{"title":"ThreadLocal 案例分析","text":"目录 123456789101112131. ThreadLocal简介 1.1 ThreadLocal基础 1.1.1 ThreadLocal和Thread的关系 1.1.2 变量的生命周期 1.2 可继承的ThreadLocal2. ThreadLocal的应用案例 2.1 解决并发问题 2.1.1 java.lang.ThreadLocalRandom 2.1.2 HDFS中的Statistics：实现高并发下的统计功能 2.2 解决数据存储问题 2.2.1 Struts2的ActionContext设计原理 2.2.2 Spring中thread scope Bean3. 总结 1. ThreadLocal简介 这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。 1.1 ThreadLocal基础为什么需要ThreadLocal要理解为什么需要ThreadLocal就不得不从线程安全问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于如何平衡高性能和数据一致性。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。 所谓的一致性，就是关联数据之间的逻辑关系是否正确和完整。 通过下面示例对数据一致性问题进行说明： 1234567891011121314151617181920212223242526272829public class ThreadLocalDemo { public static void main(String[] args) throws InterruptedException { int nThreads = 10; final Counter counter = new Counter(); ExecutorService exec = Executors.newFixedThreadPool(nThreads); final CountDownLatch latch = new CountDownLatch(nThreads); for(int i = 0; i &lt; nThreads; i++){ exec.submit(new Runnable(){ public void run(){ for(int i = 0; i &lt; 10000; i++){ counter.increase(); } latch.countDown(); } }); } latch.await(); System.out.println(&quot;Expected:&quot; + nThreads * 10000 + &quot;,Actual:&quot; + counter.count); } static class Counter{ int count = 0; public void increase(){ this.count++; } } 输出： Expected:100000,Actual:71851 可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是加锁，本质是并发访问到串行访问的改变。如下： 1234567static class Counter{ int count = 0; public synchronized void increase(){ this.count++; } } 输出： Expected:100000,Actual:100000 第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用synchronized修饰过后，串行访问时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？ 让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。 1.1.1 ThreadLocal和Thread的联系在上面提到了数据副本,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下： 12345678public class Thread implements Runnable { //。。。 ThreadLocal.ThreadLocalMap threadLocals = null; //。。。 } ThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：ThreadLocalMap的key和value该如何设计呢？ 从API角度来说，ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的key就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值： 1234567891011121314public class ThreadLocal&lt;T&gt; { private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } //。。。} 变量副本的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下： get()操作 12345678910111213141516171819202122public T get() { Thread t = Thread.currentThread();//获取当前Thread对象引用 ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; } return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化}private T setInitialValue() { //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。 T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;} set操作 12345678public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} 和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。 remove操作 12345public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);} 1.1.2 变量的生命周期这里所的变量指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期: Init第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下： 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} Service只要线程活着且ThreadLocal可访问即处于Service阶段。 Destroy由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。 ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员变量。所以其生命周期当然也就和该类一致。 1.2 可继承的ThreadLocal首先看个实例： 1234567891011121314151617181920212223242526272829303132static class Context { private static final ThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT1 = new ThreadLocal&lt;HashMap&lt;String,String&gt;&gt;(){ protected HashMap&lt;String,String&gt; initialValue(){ return new HashMap&lt;String,String&gt;(); } }; private static final InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT2 = new InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt;(){ protected HashMap&lt;String,String&gt; initialValue(){ return new HashMap&lt;String,String&gt;(); } }; public static HashMap&lt;String,String&gt; getContext1() { return CONTEXT1.get(); } public static HashMap&lt;String,String&gt; getContext2() { return CONTEXT2.get(); }}public static void main(String[] args) throws InterruptedException { Context.getContext1().put(&quot;name&quot;, &quot;wqx&quot;); Context.getContext2().put(&quot;name&quot;, &quot;wqx&quot;); Thread thread = new Thread(new Runnable(){ @Override public void run() { System.out.println(&quot;name:&quot; + Context.getContext1().get(&quot;name&quot;)); System.out.println(&quot;name:&quot; + Context.getContext2().get(&quot;name&quot;)); } }); thread.start(); } 输出： name:null name:wqx 字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段： 1234Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); 2. ThreadLocal的应用案例2.1 解决并发问题2.1.1 java.lang.ThreadLocalRandom在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法： 123456789protected int next(int bits) { long oldseed, nextseed; AtomicLong seed = this.seed; do { oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) &amp; mask; } while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed &gt;&gt;&gt; (48 - bits));} 可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。 123456789101112public class ThreadLocalRandom extends Random { //。。。 private static final ThreadLocal&lt;ThreadLocalRandom&gt; localRandom = new ThreadLocal&lt;ThreadLocalRandom&gt;() { protected ThreadLocalRandom initialValue() { return new ThreadLocalRandom(); } }; //。。。} ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。 2.1.2 HDFS中的Statistics：实现高并发下的统计功能Hadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？ 方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！ 方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储统计数据的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到写多读少的事实，ThreadLocal方案是可以接受的。 下面是Statistics对象的部分实现： 123456789101112131415161718192021222324252627282930313233343536373839public static final class Statistics { /** * Statistics data. * / public static class StatisticsData { volatile long bytesRead; volatile long bytesWritten; volatile int readOps; volatile int largeReadOps; volatile int writeOps; //。。。 } //allData保存的是所有线程中StatisticsData对象的引用 private final Set&lt;StatisticsDataReference&gt; allData; //ThreadLocal变量 private final ThreadLocal&lt;StatisticsData&gt; threadData; public void incrementBytesWritten(long newBytes) { getThreadStatistics().bytesWritten += newBytes; } public StatisticsData getThreadStatistics() { StatisticsData data = threadData.get(); if (data == null) { //第一次统计操作时需要进行初始化，并与allData进行关联 data = new StatisticsData(); threadData.set(data); StatisticsDataReference ref = new StatisticsDataReference(data, Thread.currentThread()); synchronized(this) { allData.add(ref); } } return data; } //。。。} 下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。 12345678public class DistributedFileSystem extends FileSystem { @Override public boolean delete(Path f, final boolean recursive) throws IOException { statistics.incrementWriteOps(1); // 。。。 }} 如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数： 1234567891011121314151617181920212223public long getBytesWritten() { return visitAll(new StatisticsAggregator&lt;Long&gt;() { private long bytesWritten = 0; @Override public void accept(StatisticsData data) { bytesWritten += data.bytesWritten; } public Long aggregate() { return bytesWritten; } });}//加锁处理，保证统计数据的正确性private synchronized &lt;T&gt; T visitAll(StatisticsAggregator&lt;T&gt; visitor) { visitor.accept(rootData); for (StatisticsDataReference ref: allData) { StatisticsData data = ref.getData(); visitor.accept(data); } return visitor.aggregate();} 在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！ 2.2 解决数据存储问题2.2.1 Struts2的ActionContext设计原理Struts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：Action中的每个方法的请求参数怎么获得的?处理结果又是如何返回的?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。 Struts2的最大亮点也许就是对数据流和控制流的解耦。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。 首先看下Struts2中几个主要组件的示意图： ActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的请求的生命周期可以泛指处理请求的线程的生命周期。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构： 12345678910111213141516171819public class ActionContext implements Serializable { //。。。 static ThreadLocal&lt;ActionContext&gt; actionContext = new ThreadLocal&lt;ActionContext&gt;(); private Map&lt;String, Object&gt; context; public ActionContext(Map&lt;String, Object&gt; context) { this.context = context; } public static ActionContext getContext() { return actionContext.get(); } public Map&lt;String, Object&gt; getContextMap() { return context; } //。。。 ActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一解耦思路值得好好学习。Another brilliant idea！ 2.2.1 Spring中thread scope Bean在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope： 1234567891011121314151617181920212223public class SimpleThreadScope implements Scope { private final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope = new NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt;(&quot;SimpleThreadScope&quot;) { @Override protected Map&lt;String, Object&gt; initialValue() { return new HashMap&lt;String, Object&gt;(); } }; @Override public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) { Map&lt;String, Object&gt; scope = this.threadScope.get(); Object object = scope.get(name); if (object == null) { object = objectFactory.getObject(); scope.put(name, object); } return object; } //。。。} 3. 总结上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种以空间换时间的思路，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。","link":"/2021/12/13/ThreadLocal%20%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"},{"title":"Web开发中的乱码问题","text":"主要内容1234567891011121314151617181. 字符编码理论简述 1.1 ASCII 1.2 ISO8859-1 1.3 Unicode 1.4 GBK 2. 可能发生的中文乱码 2.1 中文变问号，如：??? 2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ 2.3 中文变“复杂中文”，如：浣犲ソ 2.4 中文变成一堆黑色菱形+问号，如：�����3. Web开发中涉及到的中文编解码 3.1 URL中出现的中文 3.2 Form表单中出现的中文 3.3 JSP中涉及的编码 3.4 文件的上传和下载中涉及到的中文乱码4. 总结 1. 字符编码理论简述本文主要是围绕Web开发中涉及到的中文编码这一常见问题展开，包括了对字符编码基础理论的简述以及常见几种编码标准的介绍。其中包括：ASCII、ISO8859-1、Unicode、GBK。下面先对这些字符编码集进行简单的介绍。 1.1 ASCIIASCII也就是美国信息交换标准码，采用单字节编码方案，但是编码只用了后七位字节，表示范围0-127共128个字符。ASCII码相对于其它编码也是最早出现的。从上世纪60年代提出开始，到1986年最终定型。 为什么选择7位编码?ASCII在最初设计的时候需要至少能表示64个码元：包括26个字母+10个数字+图形标示+控制字符，如果用6bit编码，可扩展部分没有了，所以至少需要7bit。那么8bit呢？最终也被标准委员会否定，原因很简单：满足编码需求的前提下，最小化传输开销。 1.2 ISO8859-1ISO-8859-1也被称为Latin1，使用单字节8bit编码，可以表示256个西欧字符。其隶属于ISO8859标准的一部分，还有ISO8859-2、ISO8859-3等等。每一种编码都对应一个地区的字符集。比如：ISO8859-1表示西欧字符，ISO-8859-16表示中欧字符集，等等。 1.3 Unicode不管是ASCII还是ISO8859-1，其编码范围都是有局限的。而Unicode标准的目标就是消除传统编码的局限性。 这里的局限性一方面指编码范围的局限性：比如ASCII只能表示128个字符。还有编码兼容性方面的局限性：比如ISO8859代表的一系列编码字符集虽然可以表示大部分国家地区的字符，但是彼此的兼容性做的不好。Unicode的目标就如同其名称的含义一样：“实现字符编码统一” Unicode标准的实现方案有如下三种：UTF-8、UTF-16和UTF-32**. UTF-8是变长编码，使用1到4个字节。UTF-8在设计时考虑到向前兼容，所以其前128个字符和ASCII完全一样，也就是说，所有ASCII同时也都符合UTF-8编码格式。其格式如下： 12340xxxxxxx110xxxxx 10xxxxxx1110xxxx 10xxxxxx 10xxxxxx11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 字节首部为0的话，也就是前面说的ASCII了。此外，字节首部连续1的个数就代表了该字符编码后所占的字节数。目前全世界的网页编码绝大多数使用的就是UTF-8，占比接近90%。 UTF-16也是变长编码，但其最初是固定16-bit宽度的定长编码，主要因为Unicode涵盖的字符太多了。两字节更本不够用！ UTF-32是32-bit定长编码，优点：定长编码在处理效率上相对于变长编码要高，此外，可通过索引访问任意字符是其另一大优势；缺点也很明显：32bit太浪费了！存储效率太低！ big-endian和little-endian？在多字节编码标准中可能会遇到这样的问题：假如一个字符用两个字节表示，那么当读取这个字符的时候，哪个字节表示高有效位？哪个表示低有效位呢？这就涉及到字节的存储顺序问题。在Unicode中UTF-16和UTF-32都会面临这个问题。通常用BOM（Byte Order Mark）来进行区分。BOM用一个”U+FEFF”来表示，这个值在Unicode中是没有对应字符的。不仅可以用其来指定字节顺序，还可以表示字节流的编码方式。 12System.out.println(&quot;len1:&quot; + &quot;a&quot;.getBytes(&quot;UTF16&quot;).length);System.out.println(&quot;len2:&quot; + &quot;aa&quot;.getBytes(&quot;UTF16&quot;).length); 输出结果： len1:4 len2:6 为什么是4和6，不应该是2和4吗！？。输出编码后的字节序列可以发现，起始的两个字节都是：”fe ff”。 Java的char类型用什么编码格式？Java语言规范规定了Java的char类型使用的是UTF-16。这就是为什么Java的char占用两个字节的原因。此外，Java标准库实现的对char与String的序列化规定使用UTF-8。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16，当然，在设计java的时候UTF-16还是定长的）与外部存储的空间效率（采用变长的UTF-8编码）而做的取舍。 1.4 GBKGBK是用于对简体中文进行编码。每个字符用两字节表示，同时兼容GB2312标准。 2. 可能发生的中文乱码这一小节介绍软件开发中常见的中文编码乱码问题，在下面示例中：对于给定的一个包含中文的字符串”你好Java”，看一下都会出现哪些乱码问题。 2.1 中文变问号，如：?????1&quot;你好Java&quot; ------&gt; &quot;??Java&quot; 这种情况一般是由于中文字符经ISO8859-1编码造成的。下面是编码的具体过程： 原字符串：”你好Java” 你 好 J a v a 4f60 597d 4a 61 76 61 经ISO8859-1编码后： 你 好 J a v a 3f 3f 4a 61 76 61 编码后字符串：”??Java” 123456String str = &quot;你好Java&quot;;System.out.println(byteToHexString(str.getBytes(CHARSET_ISO88591)));System.out.println(new String(str.getBytes(CHARSET_ISO88591)));输出：3f 3f 4a 61 76 61??Java 我们知道ISO8859-1是单字节编码，而对于汉字已经超出ISO8859-1的编码范围，会被转化为”3f”，我们查表可知，”3f”对应的字符正是”?”。 中文变问号的乱码情况是非常常见的，大部分开源软件的默认编码设置成了ISO8859-1，这点需要格外注意。 2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ1&quot;你好Java&quot; ------&gt; &quot;ä½ å¥½Java&quot; 原字符串：”你好Java” 你 好 J a v a 4f60 597d 4a 61 76 61 经UTF-8编码后，一个中文用三个字节表示： 你 | 好 | J| a| v| a—|—|—|—|—|—|—|—e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61 乱码原因：UTF8编码或GBK编码，再由ISO8859-1解码。对照ISO8859-1编码表后发现：e4 bd a0分别对应三个字符：”ä½ “,e5 a5 bd分别对应三个字符”å¥½”, 2.3 中文变“复杂中文”如：浣犲ソ下面依然是”你好Java”经过UTF-8编码后对应的字节序列： 你 | 好 | J| a| v| a—|—|—|—|—|—|—|—e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61 在GBK表中查找：e4 bd对应字符：”浣”,a0 e5对应字符：”犲”,a5 bd对应字符：”ソ” 同理，如果GBK编码的中文用UTF-8来解码的话，同样会出现乱码问题。 2.4 中文变成一堆黑色菱形+问号，如：�����首先问号+黑色菱形的字符是Unicode中的”REPLACEMENT CHARACTER”,该字符的主要作用是用来表示不识别的字符。所以产生乱码的原因可能有很多，下面通过原字符串：”你好Java”，重现一种乱码方式： 123456789原字符串：String str = &quot;你好Java&quot;你 | 好 | J| a| v| a---|---|---|---|---|---4f60 | 597d | 4a| 61| 76| 61UTF-16编码后fe ff 4f 60 59 7d 0 4a 0 61 0 76 0 61 其中”fe ff”就是字节流起始的BOM标识符。”fe ff”在Unicode标准中属于”noncharacters”,只用于内部使用。所以，在输出该字节序列的时候，没有该码元对应的字符，对于不识别字符，就会用��替代。 3. Web开发中涉及到的中文编解码Web中的数据大多通过http协议进行传输，所涉及到的一些编解码问题都围绕着http协议。下面以Tomcat作为Web服务器，探讨下一个完整的请求响应流程中哪些地方会涉及到中文的编解码。 3.1 url编解码web环境中的中文乱码问题，实验如下： 1234567891011121314151617181920212223242526272829jsp中的form表单：&lt;body&gt; &lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;manager/codec/你好&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名： &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt; &lt;/td&gt; &lt;td&gt;地址 &lt;input type=&quot;text&quot; name=&quot;address&quot; id=&quot;address&quot; /&gt; &lt;/td&gt; &lt;th&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;保存&quot; /&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;后端使用SpringMVC的Controller：@Controller()@RequestMapping(&quot;/manager&quot;)public class ManagerController { @RequestMapping(&quot;/test/{param}&quot;) @ResponseBody public String test(@PathVariable String param, HttpServletRequest request){ String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;name:&quot; + name + &quot;,param:&quot; + param); return &quot;test&quot;; }} 表单中填入内容：用户名：你好 Java地址：123提交请求，firebug中的显示的url如下： http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD 查阅编码可以，firefox对url中出现的中文使用了UTF-8的编码方式。之所以url中出现%，这是因为根据URL编码规范，浏览器会将非ASCII字符编成16进制后，每个字节前需要加%。 后端控制台输出： 1name:ä½ å¥½ Java,param:ä½ å¥½ 可见无论是url中的中文信息或是post表单中的中文都出现了乱码现象，从前一节中关于乱码情况的分析来看，这里应该是中文字符经过浏览器UTF-8编码后，Server端用ISO8859-1进行解码所致。下面逐个分析url和post表单如何进行编解码的。 在tomcat中url的byte -&gt; char的转换是在org.apache.catalina.connector.CoyoteAdapter类的convertURI(MessageBytes uri, Request request)方法中执行的，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243 protected void convertURI(MessageBytes uri, Request request)throws Exception { ByteChunk bc = uri.getByteChunk(); int length = bc.getLength(); CharChunk cc = uri.getCharChunk(); cc.allocate(length, -1); //这里获取的connector的URIEncoding属性，即server.xml文件中connector元素的URIEncoding属性 String enc = connector.getURIEncoding(); if (enc != null) { B2CConverter conv = request.getURIConverter(); try { if (conv == null) { conv = new B2CConverter(enc, true); request.setURIConverter(conv); } else { conv.recycle(); } } catch (IOException e) { log.error(&quot;Invalid URI encoding; using HTTP default&quot;); connector.setURIEncoding(null); } if (conv != null) { try { conv.convert(bc, cc, true); uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength()); return; } catch (IOException ioe) { request.getResponse().sendError( HttpServletResponse.SC_BAD_REQUEST); } } } // 如果没有配置URIEncoding，则在ByteChunk中默认使用ISO8859-1。 byte[] bbuf = bc.getBuffer(); char[] cbuf = cc.getBuffer(); int start = bc.getStart(); for (int i = 0; i &lt; length; i++) { cbuf[i] = (char) (bbuf[i + start] &amp; 0xff); } uri.setChars(cbuf, 0, length); } 在org.apache.tomcat.util.buf.ByteChunk中可以看到默认编码的定义： 12345678public final class ByteChunk implements Cloneable, Serializable { //。。。 public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1; //。。。} 所以对于请求url中的中文，我们按UTF-8进行编码，在服务端却按ISO8859-1进行解码，所以出现乱码现象。我们可以再Tomcat的server.xml中指定url的编解码格式，如下： 12&lt;Connector URIEncoding=&quot;UTF-8&quot; 。。。&gt; 此时重复上面实验，后端控制台输出：name:ä½ å¥½ Java,param:你好 虽然url中的参数可以正常显示了，但是form表单中的参数name依然乱码，下面进一步分析。 3.2 form表单元素的编解码name参数的编码依然是乱码的，为啥？首先定位form表单中参数是在哪里进行解码的。Form表单中的字符解码时机是发生在第一次调用request.getParameter时，可以通过request.setCharacterEncoding设置。需要注意的是setCharacterEncoding必须在getParameter之前调用！否则，setCharacterEncoding不会起作用。 Tomcat中HttpServletRequest接口的实现类是org.apache.catalina.connector.Request。下面是Request类中getParameter源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 @Override public String getParameter(String name) { //判断参数是否被解析过 if (!parametersParsed) { parseParameters();//第一次参数解析 } return coyoteRequest.getParameters().getParameter(name); }//下面是parseParameters部分源码 protected void parseParameters() { //设为true，表示参数已解析过 parametersParsed = true; //Parameters对象封装了form表单参数 Parameters parameters = coyoteRequest.getParameters(); boolean success = false; try { // Set this every time in case limit has been changed via JMX parameters.setLimit(getConnector().getMaxParameterCount()); //获取字符编码格式 String enc = getCharacterEncoding(); boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI(); if (enc != null) { //getCharacterEncoding不为null，则对应设置编码方式 parameters.setEncoding(enc); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding(enc); } } else { //如果enc为null，则编码方式设置为DEFAULT_CHARACTER_ENCODING，也就是ISO8859-1 parameters.setEncoding (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); if (useBodyEncodingForURI) { parameters.setQueryStringEncoding (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING); } } parameters.handleQueryParameters(); 。。。 } } 从以上源码中可以看出为什么需要在第一次调用getParameter之前设置CharacterEncoding。因为第一次执行parseParameters时，会把parametersParsed变量设为true。所以parseParameters只会在第一次getParameter时调用。有时会出现这么一种怪像：通过request.getCharacterEncoding()得到的是我们认为正确的编码字符集，但是request.getParameter得到的依然是乱码。此时就需要考虑下我们调用setCharacterEncoding之前是否已经调用过getParameter方法了。 经过上面的分析后，对于form表单参数乱码问题就很好解决了，在第一次调用request.getParameter方法前，通过request.setCharacterEncoding(“Expected_Encoding”);设置即可。这一步可以用Servlet标准中的Filter实现，不过，常用的MVC框架中已经有现成的Filter实现了，比如SpringMVC中的org.springframework.web.filter.CharacterEncodingFilter,如下： 12345678910111213@Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) { request.setCharacterEncoding(this.encoding);//设置指定的编码 if (this.forceEncoding) { response.setCharacterEncoding(this.encoding); } } filterChain.doFilter(request, response);} 3.3 JSP中涉及的编码jsp中可以通过page指令指定一些编码参数，如下： 12&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; pageEncoding=”UTF-8”在什么时候起作用？在Servlet标准中，jsp最终也会被编译成一个servlet。index.jsp-&gt;index_jsp.java.pageEncoding=”UTF-8”就是在这个解析过程中起作用的。 contentType=”text/html; charset=UTF-8”的作用？contentType是响应头中特定信息，主要的作用是告诉浏览器response中存放的主体对象类型和编码，这样浏览器就可以对指定类型进行正确解码，保证了数据在server和client端的一致性。当进行Servlet编程的时候，可以手动进行设置，如下： 1response.setContentType(&quot;text/html; charset=UTF-8&quot;); 3.4 文件的上传和下载中涉及到的中文乱码Web中的文件操作主要是上传和下载，这个过程也是依托于Http协议作为数据载体。所以，最终是否乱码重点在于是否正确的设置http的request、response的header中的相关字段。如ContentType、Content-Disposition的设定等。如下： 12345response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);response.setDateHeader(&quot;Expires&quot;, 0);response.setContentType(&quot;application/x-msdownload&quot;);response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;); 这里需要注意的是Content-Disposition的filename属性值，如果fileName含有中文，那么要格外注意fileName字符串的编码格式。在rfc5987对于HTTP的Header中参数的编码做出了明确的规定： By default, message header field parameters in Hypertext Transfer Protocol (HTTP) messages cannot carry characters outside the ISO-8859-1 character set. 也就是说默认情况下，Http的Header中的参数只能用ISO-8859-1字符集中的字符，那么是否意味着Content-Disposition中的fileName字符串也要转成ISO-8859-1了呢？答案是：NO！原因如下：Content-Disposition其实不属于Http/1.1标准。这在RFC2616中有明确的说明。只因为其使用广泛，HTTP才对其支持。在rfc6266中也详细介绍了Content-Disposition的filename参数含义和用法。下面是对于下载包含中文名称的文件时的解决方案。 解决方案最简单就是直接用ISO8859-1对文件名进行编码，大多数浏览器都支持。如下： 1exportFileName.getBytes(&quot;UTF-8&quot;),&quot;ISO8859-1&quot;);//这里的UTF-8也可能是别的编码，主要依据系统默认的编码来设定。 或通过其它编码，如UTF-8。 12response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename*=UTF-8''&quot; + URLEncoder.encode(exportFileName, &quot;UTF8&quot;)); 4. 总结编解码问题是多语言交互系统中必然要面对的问题，尤其对于中文环境中的开发者来说，在入门阶段或多或少都会遇到此类问题。乱码问题本质就是通信双方使用的标准不一致。所以，解决乱码问题的方法其实也很简单，统一下编解码标准即可。此外，深入理解各种编码标准的原理和关系也非常重要，在以后遇到类似问题的时候能够更加准确的判断出造成乱码的原因。","link":"/2021/12/13/Web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"源码分析","slug":"Java/源码分析","link":"/categories/Java/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}]}