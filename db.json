{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"ae714e8b9718582ce44bd5686d47112f78d1c4cf","modified":1639378707765},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1639365338685},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1639365338685},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1639365344388},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1639365334796},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1639365344388},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1639365344388},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1639365344388},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1639365344385},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1639365344387},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1639365344389},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1639365344390},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1639365344391},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1639365344407},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1639365344408},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1639365344389},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1639365338272},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1639365334799},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1639365334799},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1639365339833},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1639365334800},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1639365339833},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1639365334796},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1639365338684},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1639365334797},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1639365334798},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1639365339833},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1639365334800},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1639365339834},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1639365339834},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1639365339834},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1639365339834},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1639365339834},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1639365339835},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1639365338683},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1639365338273},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1639365344381},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1639365343367},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1639365339831},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1639365335577},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1639365342603},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1639365338265},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1639365340973},{"_id":"public/2021/12/13/hello-world/index.html","hash":"193003236d552a3bd771415f31418e7b198730ba","modified":1639366049791},{"_id":"public/index.html","hash":"470e61d9e7f49f9b2311a9e70a8fcd3231d91473","modified":1639366049791},{"_id":"public/archives/2021/index.html","hash":"b7c2b5bc4ff895bb7754231ed497ed0667d58d11","modified":1639366049791},{"_id":"public/archives/2021/12/index.html","hash":"2ceab8621a544d17045550d39ef7479fc57a1233","modified":1639366049791},{"_id":"public/archives/index.html","hash":"2375580d9a0b0b1d45256dc2e5a5f71ca3bf6af3","modified":1639366049791},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1639366049791},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1639366049791},{"_id":"public/css/style.css","hash":"263d98c93ae32dda6f7bbc8473105f3c441aca99","modified":1639366049791},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1639366049791},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1639366049791},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1639366049791},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1639366049791},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1639366049791},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1639366049791},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1639366049791},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1639366049791},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1639366049791},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450715},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450716},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450716},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450717},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450717},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450711},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450712},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450713},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450713},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1639376450712},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1639376450711},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1639376450709},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1639376450710},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1639376450711},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1639376450711},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1639376450711},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1639376450711},{"_id":"themes/icarus/package.json","hash":"653d306a010f669192883483414da500d48cf592","modified":1639376450717},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1639376450710},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1639376450711},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1639376450711},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1639376450710},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1639376450711},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1639376450714},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1639376450714},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1639376450714},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1639376450714},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1639376450714},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1639376450714},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1639376450714},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1639376450715},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1639376450715},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1639376450715},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1639376450715},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1639376450715},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1639376450715},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1639376450715},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1639376450715},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1639376450715},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1639376450715},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1639376450715},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1639376450716},{"_id":"themes/icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1639376450716},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1639376450716},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1639376450717},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1639376450717},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1639376450717},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1639376450717},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1639376450710},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"b49270a202d839c298e584b5d017f56140c7e7a0","modified":1639376450710},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1639376450710},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1639376450710},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1639376450710},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1639376450710},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"71f04b66e48f065285ba109939999876ef411598","modified":1639376450710},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"69046b3b5c3d12cdca26380b7458cebeb2546dae","modified":1639376450711},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1639376450710},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1639376450711},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1639376450711},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1639376450710},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1639376450711},{"_id":"themes/icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1639376450713},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1639376450713},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1639376450713},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1639376450713},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1639376450713},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1639376450713},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1639376450713},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1639376450713},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1639376450713},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1639376450713},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1639376450713},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1639376450714},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1639376450714},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1639376450714},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1639376450712},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1639376450714},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1639376450714},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1639376450716},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1639376450716},{"_id":"themes/icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1639376450716},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1639376450716},{"_id":"themes/icarus/layout/common/head.jsx","hash":"0bf1c4fc3247cd7f4244080c4333e33ffef2c337","modified":1639376450716},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1639376450716},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1639376450716},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1639376450716},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1639376450716},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1639376450716},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1639376450716},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1639376450717},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1639376450717},{"_id":"themes/icarus/source/img/avatar.png","hash":"165b502049f207c1325f5f9f899f1175b50a2c34","modified":1639379934753},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"dd18f3fffaf92e2a672949fa3faa13d24c92628d","modified":1639380232594},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1639376450718},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1639376450718},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1639376450718},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1639376450718},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1639376450717},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1639376450717},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1639376450718},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1639376450718},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1639376450718},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1639376450718},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1639376450718},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1639376450712},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1639376450717},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1639376450712},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1639376450712},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1639376450718},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1639376450713},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1639376450713},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1639376450713},{"_id":"source/_posts/hello-world2.md","hash":"df1f1d59d32a11abdb0198ea35be225e9b0c3043","modified":1639378740945},{"_id":"themes/icarus/source/img/f-14.jpeg","hash":"165b502049f207c1325f5f9f899f1175b50a2c34","modified":1639379934753},{"_id":"themes/icarus/source/img/avatar.png.bak","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1639376450717},{"_id":"themes/icarus/source/img/avatar.jpeg","hash":"165b502049f207c1325f5f9f899f1175b50a2c34","modified":1639379934753},{"_id":"source/_posts/Web开发中的乱码问题.md","hash":"5dd798e374f6e58239d1fb98fe69512a4ca57970","modified":1639384560427},{"_id":"source/_posts/ThreadLocal 案例分析.md","hash":"f3095f05b22c9921d7e33d23985297bf03315a97","modified":1639385363064}],"Category":[{"name":"Java","_id":"ckx4fo2em0004cw0j7eie3e9g"},{"name":"源码分析","parent":"ckx4fo2em0004cw0j7eie3e9g","_id":"ckx4fpb8f0000x30jc1uwhzpa"}],"Data":[],"Page":[],"Post":[{"title":"ThreadLocal 案例分析","toc":true,"_content":"\n目录\n```\n1. ThreadLocal简介\n    1.1 ThreadLocal基础\n        1.1.1 ThreadLocal和Thread的关系\n        1.1.2 变量的生命周期\n    1.2 可继承的ThreadLocal\n2. ThreadLocal的应用案例\n    2.1 解决并发问题\n        2.1.1 java.lang.ThreadLocalRandom\n        2.1.2 HDFS中的Statistics：实现高并发下的统计功能\n    2.2 解决数据存储问题\n        2.2.1 Struts2的ActionContext设计原理\n        2.2.2 Spring中thread scope Bean\n3. 总结\n```\n## 1. ThreadLocal简介\n> 这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。\n\n### 1.1 ThreadLocal基础\n###### 为什么需要ThreadLocal\n要理解为什么需要ThreadLocal就不得不从**线程安全**问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于**如何平衡高性能和数据一致性**。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。\n> 所谓的**一致性**，就是关联数据之间的逻辑关系是否正确和完整。\n\n通过下面示例对数据一致性问题进行说明：\n```\npublic class ThreadLocalDemo {\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tint nThreads = 10;\n\t\tfinal Counter counter = new Counter();\n\t\t\n\t\tExecutorService exec = Executors.newFixedThreadPool(nThreads);\n\t\tfinal CountDownLatch latch = new CountDownLatch(nThreads);\n\t\t\n\t\tfor(int i = 0; i < nThreads; i++){\n\t\t\texec.submit(new Runnable(){\n\t\t\t\tpublic void run(){\n\t\t\t\t\tfor(int i = 0; i < 10000; i++){\n\t\t\t\t\t\tcounter.increase();\n\t\t\t\t\t}\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tlatch.await();\n\t\tSystem.out.println(\"Expected:\" + nThreads * 10000 + \",Actual:\" + counter.count);\n\t}\n\tstatic class Counter{\n\t\tint count = 0;\n\t\t\n\t\tpublic void  increase(){\n\t\t\tthis.count++;\n\t\t}\n\t}\n```\n输出：\n> Expected:100000,Actual:71851\n\n可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是**加锁**，本质是**并发访问**到**串行访问**的改变。如下：\n```\n\tstatic class Counter{\n\t\tint count = 0;\n\t\t\n\t\tpublic synchronized void  increase(){\n\t\t\tthis.count++;\n\t\t}\t\t\n\t}\n```\n输出：\n> Expected:100000,Actual:100000\n\n第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用**synchronized**修饰过后，**串行访问**时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？\n\n> 让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。\n\n#### 1.1.1 ThreadLocal和Thread的联系\n在上面提到了**数据副本**,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下：\n```\npublic class Thread implements Runnable {\n    \n    //。。。\n    \n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    \n    //。。。    \n}\n```\nThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：**ThreadLocalMap的key和value该如何设计呢？**\n\n从API角度来说，**ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口**，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的**key**就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值：\n```\npublic class ThreadLocal<T> {\n\n    private final int threadLocalHashCode = nextHashCode();\n\n    private static AtomicInteger nextHashCode =\n        new AtomicInteger();\n\n    private static final int HASH_INCREMENT = 0x61c88647;\n\n    private static int nextHashCode() {\n        return nextHashCode.getAndAdd(HASH_INCREMENT);\n    }\n    //。。。\n}\n```\n\n**变量副本**的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下：\n\n1. get()操作\n```\n    public T get() {\n        Thread t = Thread.currentThread();//获取当前Thread对象引用\n        ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化\n    }\n    \n    private T setInitialValue() {\n        //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }    \n```\n2. set操作\n```\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。\n3. remove操作\n```\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n#### 1.1.2 变量的生命周期\n这里所的**变量**指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期:\n1. Init\n第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下：\n```\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n2. Service\n只要线程活着且ThreadLocal可访问即处于Service阶段。\n\n3. Destroy\n由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。\n\n> ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员\n变量。所以其生命周期当然也就和该类一致。\n\n### 1.2 可继承的ThreadLocal\n首先看个实例：\n```\n\tstatic class Context {\n\n\t\tprivate static final ThreadLocal<HashMap<String,String>> CONTEXT1 = new ThreadLocal<HashMap<String,String>>(){\n\t\t\tprotected HashMap<String,String> initialValue(){\n\t\t\t\treturn new HashMap<String,String>();\n\t\t\t}\n\t\t};\n\t\tprivate static final InheritableThreadLocal<HashMap<String,String>> CONTEXT2 = new InheritableThreadLocal<HashMap<String,String>>(){\n\t\t\tprotected HashMap<String,String> initialValue(){\n\t\t\t\treturn new HashMap<String,String>();\n\t\t\t}\n\t\t};\t\t\n\t\tpublic static HashMap<String,String> getContext1() {\n\t\t\treturn CONTEXT1.get();\n\t\t}\n\t\tpublic static HashMap<String,String> getContext2() {\n\t\t\treturn CONTEXT2.get();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tContext.getContext1().put(\"name\", \"wqx\");\n\t\tContext.getContext2().put(\"name\", \"wqx\");\n\t\tThread thread = new Thread(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"name:\" + Context.getContext1().get(\"name\"));\n\t\t\t\tSystem.out.println(\"name:\" + Context.getContext2().get(\"name\"));\n\t\t\t}\n\t\t});\n\t\tthread.start();\n    }\n```\n输出：\n> name:null\n\n> name:wqx\n\n字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段：\n```\n    Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程\n    if (parent.inheritableThreadLocals != null)\n        this.inheritableThreadLocals =\n            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n```\n\n## 2. ThreadLocal的应用案例\n### 2.1 解决并发问题\n#### 2.1.1 java.lang.ThreadLocalRandom\n在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法：\n```\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。\n```\npublic class ThreadLocalRandom extends Random {\n    \n    //。。。\n    \n    private static final ThreadLocal<ThreadLocalRandom> localRandom =\n        new ThreadLocal<ThreadLocalRandom>() {\n            protected ThreadLocalRandom initialValue() {\n                return new ThreadLocalRandom();\n            }\n    };\n    //。。。\n}\n```\n> ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。\n\n#### 2.1.2 HDFS中的Statistics：实现高并发下的统计功能\nHadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？\n\n> 方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！\n\n> 方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储**统计数据**的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到**写多读少**的事实，ThreadLocal方案是可以接受的。\n\n下面是Statistics对象的部分实现：\n```\npublic static final class Statistics {\n\n    /**\n     * Statistics data.\n     * /\n    public static class StatisticsData {\n      volatile long bytesRead;\n      volatile long bytesWritten;\n      volatile int readOps;\n      volatile int largeReadOps;\n      volatile int writeOps;\n      //。。。\n    }\n\n    //allData保存的是所有线程中StatisticsData对象的引用\n    private final Set<StatisticsDataReference> allData;\n    \n    //ThreadLocal变量\n    private final ThreadLocal<StatisticsData> threadData;\n    \n    public void incrementBytesWritten(long newBytes) {\n      getThreadStatistics().bytesWritten += newBytes;\n    }\n    \n    public StatisticsData getThreadStatistics() {\n      StatisticsData data = threadData.get();\n      if (data == null) {   //第一次统计操作时需要进行初始化，并与allData进行关联\n        data = new StatisticsData();\n        threadData.set(data);\n        StatisticsDataReference ref =\n            new StatisticsDataReference(data, Thread.currentThread());\n        synchronized(this) {\n          allData.add(ref);\n        }\n      }\n      return data;\n    }    \n    //。。。\n}\n```\n下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。\n```\npublic class DistributedFileSystem extends FileSystem {\n\n  @Override\n  public boolean delete(Path f, final boolean recursive) throws IOException {\n    statistics.incrementWriteOps(1);\n    // 。。。\n  }\n}\n```\n如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数：\n```\n    public long getBytesWritten() {\n      return visitAll(new StatisticsAggregator<Long>() {\n        private long bytesWritten = 0;\n\n        @Override\n        public void accept(StatisticsData data) {\n          bytesWritten += data.bytesWritten;\n        }\n\n        public Long aggregate() {\n          return bytesWritten;\n        }\n      });\n    }\n    //加锁处理，保证统计数据的正确性\n    private synchronized <T> T visitAll(StatisticsAggregator<T> visitor) {\n      visitor.accept(rootData);\n      for (StatisticsDataReference ref: allData) {\n        StatisticsData data = ref.getData();\n        visitor.accept(data);\n      }\n      return visitor.aggregate();\n    }\n```\n在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！\n\n### 2.2 解决数据存储问题\n#### 2.2.1 Struts2的ActionContext设计原理\nStruts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：**Action中的每个方法的请求参数怎么获得的**?**处理结果又是如何返回的**?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。\n\n> Struts2的**最大亮点也许就是对数据流和控制流的解耦**。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。\n\n首先看下Struts2中几个主要组件的示意图：\n\n![Struts2组件示意图](http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的**请求的生命周期**可以泛指**处理请求的线程的生命周期**。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构：\n```\npublic class ActionContext implements Serializable {\n\n    //。。。\n    \n    static ThreadLocal<ActionContext> actionContext = new ThreadLocal<ActionContext>();\n    \n    private Map<String, Object> context;\n\n    public ActionContext(Map<String, Object> context) {\n        this.context = context;\n    }\n    \n    public static ActionContext getContext() {\n        return actionContext.get();\n    }\n    public Map<String, Object> getContextMap() {\n        return context;\n    }\n    //。。。\n```\nActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一**解耦思路**值得好好学习。Another brilliant idea！\n\n#### 2.2.1 Spring中thread scope Bean\n在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容\n易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope：\n```\npublic class SimpleThreadScope implements Scope {\n\n\tprivate final ThreadLocal<Map<String, Object>> threadScope =\n\t\t\tnew NamedThreadLocal<Map<String, Object>>(\"SimpleThreadScope\") {\n\t\t\t\t@Override\n\t\t\t\tprotected Map<String, Object> initialValue() {\n\t\t\t\t\treturn new HashMap<String, Object>();\n\t\t\t\t}\n\t\t\t};\n\n\t@Override\n\tpublic Object get(String name, ObjectFactory<?> objectFactory) {\n\t\tMap<String, Object> scope = this.threadScope.get();\n\t\tObject object = scope.get(name);\n\t\tif (object == null) {\n\t\t\tobject = objectFactory.getObject();\n\t\t\tscope.put(name, object);\n\t\t}\n\t\treturn object;\n\t}\n\n    //。。。\n}\n```\n## 3. 总结\n上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种**以空间换时间的思路**，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。","source":"_posts/ThreadLocal 案例分析.md","raw":"---\ntitle: ThreadLocal 案例分析\ntoc: true\ncategories:\n    - Java\n    - 源码分析\ntags:\n    - ThreadLocal\n---\n\n目录\n```\n1. ThreadLocal简介\n    1.1 ThreadLocal基础\n        1.1.1 ThreadLocal和Thread的关系\n        1.1.2 变量的生命周期\n    1.2 可继承的ThreadLocal\n2. ThreadLocal的应用案例\n    2.1 解决并发问题\n        2.1.1 java.lang.ThreadLocalRandom\n        2.1.2 HDFS中的Statistics：实现高并发下的统计功能\n    2.2 解决数据存储问题\n        2.2.1 Struts2的ActionContext设计原理\n        2.2.2 Spring中thread scope Bean\n3. 总结\n```\n## 1. ThreadLocal简介\n> 这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。\n\n### 1.1 ThreadLocal基础\n###### 为什么需要ThreadLocal\n要理解为什么需要ThreadLocal就不得不从**线程安全**问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于**如何平衡高性能和数据一致性**。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。\n> 所谓的**一致性**，就是关联数据之间的逻辑关系是否正确和完整。\n\n通过下面示例对数据一致性问题进行说明：\n```\npublic class ThreadLocalDemo {\n\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tint nThreads = 10;\n\t\tfinal Counter counter = new Counter();\n\t\t\n\t\tExecutorService exec = Executors.newFixedThreadPool(nThreads);\n\t\tfinal CountDownLatch latch = new CountDownLatch(nThreads);\n\t\t\n\t\tfor(int i = 0; i < nThreads; i++){\n\t\t\texec.submit(new Runnable(){\n\t\t\t\tpublic void run(){\n\t\t\t\t\tfor(int i = 0; i < 10000; i++){\n\t\t\t\t\t\tcounter.increase();\n\t\t\t\t\t}\n\t\t\t\t\tlatch.countDown();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tlatch.await();\n\t\tSystem.out.println(\"Expected:\" + nThreads * 10000 + \",Actual:\" + counter.count);\n\t}\n\tstatic class Counter{\n\t\tint count = 0;\n\t\t\n\t\tpublic void  increase(){\n\t\t\tthis.count++;\n\t\t}\n\t}\n```\n输出：\n> Expected:100000,Actual:71851\n\n可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是**加锁**，本质是**并发访问**到**串行访问**的改变。如下：\n```\n\tstatic class Counter{\n\t\tint count = 0;\n\t\t\n\t\tpublic synchronized void  increase(){\n\t\t\tthis.count++;\n\t\t}\t\t\n\t}\n```\n输出：\n> Expected:100000,Actual:100000\n\n第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用**synchronized**修饰过后，**串行访问**时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？\n\n> 让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。\n\n#### 1.1.1 ThreadLocal和Thread的联系\n在上面提到了**数据副本**,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下：\n```\npublic class Thread implements Runnable {\n    \n    //。。。\n    \n    ThreadLocal.ThreadLocalMap threadLocals = null;\n    \n    //。。。    \n}\n```\nThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：**ThreadLocalMap的key和value该如何设计呢？**\n\n从API角度来说，**ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口**，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的**key**就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值：\n```\npublic class ThreadLocal<T> {\n\n    private final int threadLocalHashCode = nextHashCode();\n\n    private static AtomicInteger nextHashCode =\n        new AtomicInteger();\n\n    private static final int HASH_INCREMENT = 0x61c88647;\n\n    private static int nextHashCode() {\n        return nextHashCode.getAndAdd(HASH_INCREMENT);\n    }\n    //。。。\n}\n```\n\n**变量副本**的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下：\n\n1. get()操作\n```\n    public T get() {\n        Thread t = Thread.currentThread();//获取当前Thread对象引用\n        ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null)\n                return (T)e.value;\n        }\n        return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化\n    }\n    \n    private T setInitialValue() {\n        //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }    \n```\n2. set操作\n```\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。\n3. remove操作\n```\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n#### 1.1.2 变量的生命周期\n这里所的**变量**指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期:\n1. Init\n第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下：\n```\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n2. Service\n只要线程活着且ThreadLocal可访问即处于Service阶段。\n\n3. Destroy\n由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。\n\n> ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员\n变量。所以其生命周期当然也就和该类一致。\n\n### 1.2 可继承的ThreadLocal\n首先看个实例：\n```\n\tstatic class Context {\n\n\t\tprivate static final ThreadLocal<HashMap<String,String>> CONTEXT1 = new ThreadLocal<HashMap<String,String>>(){\n\t\t\tprotected HashMap<String,String> initialValue(){\n\t\t\t\treturn new HashMap<String,String>();\n\t\t\t}\n\t\t};\n\t\tprivate static final InheritableThreadLocal<HashMap<String,String>> CONTEXT2 = new InheritableThreadLocal<HashMap<String,String>>(){\n\t\t\tprotected HashMap<String,String> initialValue(){\n\t\t\t\treturn new HashMap<String,String>();\n\t\t\t}\n\t\t};\t\t\n\t\tpublic static HashMap<String,String> getContext1() {\n\t\t\treturn CONTEXT1.get();\n\t\t}\n\t\tpublic static HashMap<String,String> getContext2() {\n\t\t\treturn CONTEXT2.get();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tContext.getContext1().put(\"name\", \"wqx\");\n\t\tContext.getContext2().put(\"name\", \"wqx\");\n\t\tThread thread = new Thread(new Runnable(){\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"name:\" + Context.getContext1().get(\"name\"));\n\t\t\t\tSystem.out.println(\"name:\" + Context.getContext2().get(\"name\"));\n\t\t\t}\n\t\t});\n\t\tthread.start();\n    }\n```\n输出：\n> name:null\n\n> name:wqx\n\n字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段：\n```\n    Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程\n    if (parent.inheritableThreadLocals != null)\n        this.inheritableThreadLocals =\n            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n```\n\n## 2. ThreadLocal的应用案例\n### 2.1 解决并发问题\n#### 2.1.1 java.lang.ThreadLocalRandom\n在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法：\n```\n    protected int next(int bits) {\n        long oldseed, nextseed;\n        AtomicLong seed = this.seed;\n        do {\n            oldseed = seed.get();\n            nextseed = (oldseed * multiplier + addend) & mask;\n        } while (!seed.compareAndSet(oldseed, nextseed));\n        return (int)(nextseed >>> (48 - bits));\n    }\n```\n可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。\n```\npublic class ThreadLocalRandom extends Random {\n    \n    //。。。\n    \n    private static final ThreadLocal<ThreadLocalRandom> localRandom =\n        new ThreadLocal<ThreadLocalRandom>() {\n            protected ThreadLocalRandom initialValue() {\n                return new ThreadLocalRandom();\n            }\n    };\n    //。。。\n}\n```\n> ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。\n\n#### 2.1.2 HDFS中的Statistics：实现高并发下的统计功能\nHadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？\n\n> 方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！\n\n> 方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储**统计数据**的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到**写多读少**的事实，ThreadLocal方案是可以接受的。\n\n下面是Statistics对象的部分实现：\n```\npublic static final class Statistics {\n\n    /**\n     * Statistics data.\n     * /\n    public static class StatisticsData {\n      volatile long bytesRead;\n      volatile long bytesWritten;\n      volatile int readOps;\n      volatile int largeReadOps;\n      volatile int writeOps;\n      //。。。\n    }\n\n    //allData保存的是所有线程中StatisticsData对象的引用\n    private final Set<StatisticsDataReference> allData;\n    \n    //ThreadLocal变量\n    private final ThreadLocal<StatisticsData> threadData;\n    \n    public void incrementBytesWritten(long newBytes) {\n      getThreadStatistics().bytesWritten += newBytes;\n    }\n    \n    public StatisticsData getThreadStatistics() {\n      StatisticsData data = threadData.get();\n      if (data == null) {   //第一次统计操作时需要进行初始化，并与allData进行关联\n        data = new StatisticsData();\n        threadData.set(data);\n        StatisticsDataReference ref =\n            new StatisticsDataReference(data, Thread.currentThread());\n        synchronized(this) {\n          allData.add(ref);\n        }\n      }\n      return data;\n    }    \n    //。。。\n}\n```\n下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。\n```\npublic class DistributedFileSystem extends FileSystem {\n\n  @Override\n  public boolean delete(Path f, final boolean recursive) throws IOException {\n    statistics.incrementWriteOps(1);\n    // 。。。\n  }\n}\n```\n如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数：\n```\n    public long getBytesWritten() {\n      return visitAll(new StatisticsAggregator<Long>() {\n        private long bytesWritten = 0;\n\n        @Override\n        public void accept(StatisticsData data) {\n          bytesWritten += data.bytesWritten;\n        }\n\n        public Long aggregate() {\n          return bytesWritten;\n        }\n      });\n    }\n    //加锁处理，保证统计数据的正确性\n    private synchronized <T> T visitAll(StatisticsAggregator<T> visitor) {\n      visitor.accept(rootData);\n      for (StatisticsDataReference ref: allData) {\n        StatisticsData data = ref.getData();\n        visitor.accept(data);\n      }\n      return visitor.aggregate();\n    }\n```\n在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！\n\n### 2.2 解决数据存储问题\n#### 2.2.1 Struts2的ActionContext设计原理\nStruts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：**Action中的每个方法的请求参数怎么获得的**?**处理结果又是如何返回的**?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。\n\n> Struts2的**最大亮点也许就是对数据流和控制流的解耦**。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。\n\n首先看下Struts2中几个主要组件的示意图：\n\n![Struts2组件示意图](http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的**请求的生命周期**可以泛指**处理请求的线程的生命周期**。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构：\n```\npublic class ActionContext implements Serializable {\n\n    //。。。\n    \n    static ThreadLocal<ActionContext> actionContext = new ThreadLocal<ActionContext>();\n    \n    private Map<String, Object> context;\n\n    public ActionContext(Map<String, Object> context) {\n        this.context = context;\n    }\n    \n    public static ActionContext getContext() {\n        return actionContext.get();\n    }\n    public Map<String, Object> getContextMap() {\n        return context;\n    }\n    //。。。\n```\nActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一**解耦思路**值得好好学习。Another brilliant idea！\n\n#### 2.2.1 Spring中thread scope Bean\n在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容\n易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope：\n```\npublic class SimpleThreadScope implements Scope {\n\n\tprivate final ThreadLocal<Map<String, Object>> threadScope =\n\t\t\tnew NamedThreadLocal<Map<String, Object>>(\"SimpleThreadScope\") {\n\t\t\t\t@Override\n\t\t\t\tprotected Map<String, Object> initialValue() {\n\t\t\t\t\treturn new HashMap<String, Object>();\n\t\t\t\t}\n\t\t\t};\n\n\t@Override\n\tpublic Object get(String name, ObjectFactory<?> objectFactory) {\n\t\tMap<String, Object> scope = this.threadScope.get();\n\t\tObject object = scope.get(name);\n\t\tif (object == null) {\n\t\t\tobject = objectFactory.getObject();\n\t\t\tscope.put(name, object);\n\t\t}\n\t\treturn object;\n\t}\n\n    //。。。\n}\n```\n## 3. 总结\n上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种**以空间换时间的思路**，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。","slug":"ThreadLocal 案例分析","published":1,"date":"2021-12-13T03:18:46.954Z","updated":"2021-12-13T08:49:23.064Z","_id":"ckx4dc2k20000k60jam42ejf7","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ThreadLocal简介</span><br><span class=\"line\">    1.1 ThreadLocal基础</span><br><span class=\"line\">        1.1.1 ThreadLocal和Thread的关系</span><br><span class=\"line\">        1.1.2 变量的生命周期</span><br><span class=\"line\">    1.2 可继承的ThreadLocal</span><br><span class=\"line\">2. ThreadLocal的应用案例</span><br><span class=\"line\">    2.1 解决并发问题</span><br><span class=\"line\">        2.1.1 java.lang.ThreadLocalRandom</span><br><span class=\"line\">        2.1.2 HDFS中的Statistics：实现高并发下的统计功能</span><br><span class=\"line\">    2.2 解决数据存储问题</span><br><span class=\"line\">        2.2.1 Struts2的ActionContext设计原理</span><br><span class=\"line\">        2.2.2 Spring中thread scope Bean</span><br><span class=\"line\">3. 总结</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-ThreadLocal简介\"><a href=\"#1-ThreadLocal简介\" class=\"headerlink\" title=\"1. ThreadLocal简介\"></a>1. ThreadLocal简介</h2><blockquote>\n<p>这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。</p>\n</blockquote>\n<h3 id=\"1-1-ThreadLocal基础\"><a href=\"#1-1-ThreadLocal基础\" class=\"headerlink\" title=\"1.1 ThreadLocal基础\"></a>1.1 ThreadLocal基础</h3><h6 id=\"为什么需要ThreadLocal\"><a href=\"#为什么需要ThreadLocal\" class=\"headerlink\" title=\"为什么需要ThreadLocal\"></a>为什么需要ThreadLocal</h6><p>要理解为什么需要ThreadLocal就不得不从<strong>线程安全</strong>问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于<strong>如何平衡高性能和数据一致性</strong>。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。</p>\n<blockquote>\n<p>所谓的<strong>一致性</strong>，就是关联数据之间的逻辑关系是否正确和完整。</p>\n</blockquote>\n<p>通过下面示例对数据一致性问题进行说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tint nThreads = 10;</span><br><span class=\"line\">\t\tfinal Counter counter = new Counter();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tExecutorService exec = Executors.newFixedThreadPool(nThreads);</span><br><span class=\"line\">\t\tfinal CountDownLatch latch = new CountDownLatch(nThreads);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt; nThreads; i++)&#123;</span><br><span class=\"line\">\t\t\texec.submit(new Runnable()&#123;</span><br><span class=\"line\">\t\t\t\tpublic void run()&#123;</span><br><span class=\"line\">\t\t\t\t\tfor(int i = 0; i &lt; 10000; i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tcounter.increase();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tlatch.countDown();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlatch.await();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Expected:&quot; + nThreads * 10000 + &quot;,Actual:&quot; + counter.count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstatic class Counter&#123;</span><br><span class=\"line\">\t\tint count = 0;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tpublic void  increase()&#123;</span><br><span class=\"line\">\t\t\tthis.count++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Expected:100000,Actual:71851</p>\n</blockquote>\n<p>可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是<strong>加锁</strong>，本质是<strong>并发访问</strong>到<strong>串行访问</strong>的改变。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Counter&#123;</span><br><span class=\"line\">\tint count = 0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic synchronized void  increase()&#123;</span><br><span class=\"line\">\t\tthis.count++;</span><br><span class=\"line\">\t&#125;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Expected:100000,Actual:100000</p>\n</blockquote>\n<p>第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用<strong>synchronized</strong>修饰过后，<strong>串行访问</strong>时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？</p>\n<blockquote>\n<p>让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。</p>\n</blockquote>\n<h4 id=\"1-1-1-ThreadLocal和Thread的联系\"><a href=\"#1-1-1-ThreadLocal和Thread的联系\" class=\"headerlink\" title=\"1.1.1 ThreadLocal和Thread的联系\"></a>1.1.1 ThreadLocal和Thread的联系</h4><p>在上面提到了<strong>数据副本</strong>,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread implements Runnable &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：<strong>ThreadLocalMap的key和value该如何设计呢？</strong></p>\n<p>从API角度来说，<strong>ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口</strong>，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的<strong>key</strong>就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final int threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static AtomicInteger nextHashCode =</span><br><span class=\"line\">        new AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int nextHashCode() &#123;</span><br><span class=\"line\">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>变量副本</strong>的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下：</p>\n<ol>\n<li><p>get()操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public T get() &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();//获取当前Thread对象引用</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量</span><br><span class=\"line\">    if (map != null) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">        if (e != null)</span><br><span class=\"line\">            return (T)e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private T setInitialValue() &#123;</span><br><span class=\"line\">    //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    if (map != null)</span><br><span class=\"line\">        map.set(this, value);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure></li>\n<li><p>set操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    if (map != null)</span><br><span class=\"line\">        map.set(this, value);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。</p>\n</li>\n<li><p>remove操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void remove() &#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    if (m != null)</span><br><span class=\"line\">        m.remove(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-1-2-变量的生命周期\"><a href=\"#1-1-2-变量的生命周期\" class=\"headerlink\" title=\"1.1.2 变量的生命周期\"></a>1.1.2 变量的生命周期</h4><p>这里所的<strong>变量</strong>指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期:</p>\n</li>\n<li><p>Init<br>第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>Service<br>只要线程活着且ThreadLocal可访问即处于Service阶段。</p>\n</li>\n<li><p>Destroy<br>由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。</p>\n</li>\n</ol>\n<blockquote>\n<p>ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员<br>变量。所以其生命周期当然也就和该类一致。</p>\n</blockquote>\n<h3 id=\"1-2-可继承的ThreadLocal\"><a href=\"#1-2-可继承的ThreadLocal\" class=\"headerlink\" title=\"1.2 可继承的ThreadLocal\"></a>1.2 可继承的ThreadLocal</h3><p>首先看个实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Context &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final ThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT1 = new ThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class=\"line\">\t\tprotected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class=\"line\">\t\t\treturn new HashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tprivate static final InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT2 = new InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class=\"line\">\t\tprotected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class=\"line\">\t\t\treturn new HashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;\t\t</span><br><span class=\"line\">\tpublic static HashMap&lt;String,String&gt; getContext1() &#123;</span><br><span class=\"line\">\t\treturn CONTEXT1.get();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static HashMap&lt;String,String&gt; getContext2() &#123;</span><br><span class=\"line\">\t\treturn CONTEXT2.get();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\tContext.getContext1().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class=\"line\">\tContext.getContext2().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class=\"line\">\tThread thread = new Thread(new Runnable()&#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;name:&quot; + Context.getContext1().get(&quot;name&quot;));</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;name:&quot; + Context.getContext2().get(&quot;name&quot;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>name:null</p>\n</blockquote>\n<blockquote>\n<p>name:wqx</p>\n</blockquote>\n<p>字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程</span><br><span class=\"line\">if (parent.inheritableThreadLocals != null)</span><br><span class=\"line\">    this.inheritableThreadLocals =</span><br><span class=\"line\">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-ThreadLocal的应用案例\"><a href=\"#2-ThreadLocal的应用案例\" class=\"headerlink\" title=\"2. ThreadLocal的应用案例\"></a>2. ThreadLocal的应用案例</h2><h3 id=\"2-1-解决并发问题\"><a href=\"#2-1-解决并发问题\" class=\"headerlink\" title=\"2.1 解决并发问题\"></a>2.1 解决并发问题</h3><h4 id=\"2-1-1-java-lang-ThreadLocalRandom\"><a href=\"#2-1-1-java-lang-ThreadLocalRandom\" class=\"headerlink\" title=\"2.1.1 java.lang.ThreadLocalRandom\"></a>2.1.1 java.lang.ThreadLocalRandom</h4><p>在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected int next(int bits) &#123;</span><br><span class=\"line\">    long oldseed, nextseed;</span><br><span class=\"line\">    AtomicLong seed = this.seed;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        oldseed = seed.get();</span><br><span class=\"line\">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class=\"line\">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class=\"line\">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalRandom extends Random &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static final ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class=\"line\">        new ThreadLocal&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class=\"line\">            protected ThreadLocalRandom initialValue() &#123;</span><br><span class=\"line\">                return new ThreadLocalRandom();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。</p>\n</blockquote>\n<h4 id=\"2-1-2-HDFS中的Statistics：实现高并发下的统计功能\"><a href=\"#2-1-2-HDFS中的Statistics：实现高并发下的统计功能\" class=\"headerlink\" title=\"2.1.2 HDFS中的Statistics：实现高并发下的统计功能\"></a>2.1.2 HDFS中的Statistics：实现高并发下的统计功能</h4><p>Hadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？</p>\n<blockquote>\n<p>方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！</p>\n</blockquote>\n<blockquote>\n<p>方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储<strong>统计数据</strong>的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到<strong>写多读少</strong>的事实，ThreadLocal方案是可以接受的。</p>\n</blockquote>\n<p>下面是Statistics对象的部分实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final class Statistics &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Statistics data.</span><br><span class=\"line\">     * /</span><br><span class=\"line\">    public static class StatisticsData &#123;</span><br><span class=\"line\">      volatile long bytesRead;</span><br><span class=\"line\">      volatile long bytesWritten;</span><br><span class=\"line\">      volatile int readOps;</span><br><span class=\"line\">      volatile int largeReadOps;</span><br><span class=\"line\">      volatile int writeOps;</span><br><span class=\"line\">      //。。。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //allData保存的是所有线程中StatisticsData对象的引用</span><br><span class=\"line\">    private final Set&lt;StatisticsDataReference&gt; allData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //ThreadLocal变量</span><br><span class=\"line\">    private final ThreadLocal&lt;StatisticsData&gt; threadData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void incrementBytesWritten(long newBytes) &#123;</span><br><span class=\"line\">      getThreadStatistics().bytesWritten += newBytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public StatisticsData getThreadStatistics() &#123;</span><br><span class=\"line\">      StatisticsData data = threadData.get();</span><br><span class=\"line\">      if (data == null) &#123;   //第一次统计操作时需要进行初始化，并与allData进行关联</span><br><span class=\"line\">        data = new StatisticsData();</span><br><span class=\"line\">        threadData.set(data);</span><br><span class=\"line\">        StatisticsDataReference ref =</span><br><span class=\"line\">            new StatisticsDataReference(data, Thread.currentThread());</span><br><span class=\"line\">        synchronized(this) &#123;</span><br><span class=\"line\">          allData.add(ref);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return data;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DistributedFileSystem extends FileSystem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public boolean delete(Path f, final boolean recursive) throws IOException &#123;</span><br><span class=\"line\">    statistics.incrementWriteOps(1);</span><br><span class=\"line\">    // 。。。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long getBytesWritten() &#123;</span><br><span class=\"line\">  return visitAll(new StatisticsAggregator&lt;Long&gt;() &#123;</span><br><span class=\"line\">    private long bytesWritten = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(StatisticsData data) &#123;</span><br><span class=\"line\">      bytesWritten += data.bytesWritten;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Long aggregate() &#123;</span><br><span class=\"line\">      return bytesWritten;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//加锁处理，保证统计数据的正确性</span><br><span class=\"line\">private synchronized &lt;T&gt; T visitAll(StatisticsAggregator&lt;T&gt; visitor) &#123;</span><br><span class=\"line\">  visitor.accept(rootData);</span><br><span class=\"line\">  for (StatisticsDataReference ref: allData) &#123;</span><br><span class=\"line\">    StatisticsData data = ref.getData();</span><br><span class=\"line\">    visitor.accept(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return visitor.aggregate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！</p>\n<h3 id=\"2-2-解决数据存储问题\"><a href=\"#2-2-解决数据存储问题\" class=\"headerlink\" title=\"2.2 解决数据存储问题\"></a>2.2 解决数据存储问题</h3><h4 id=\"2-2-1-Struts2的ActionContext设计原理\"><a href=\"#2-2-1-Struts2的ActionContext设计原理\" class=\"headerlink\" title=\"2.2.1 Struts2的ActionContext设计原理\"></a>2.2.1 Struts2的ActionContext设计原理</h4><p>Struts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：<strong>Action中的每个方法的请求参数怎么获得的</strong>?<strong>处理结果又是如何返回的</strong>?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。</p>\n<blockquote>\n<p>Struts2的<strong>最大亮点也许就是对数据流和控制流的解耦</strong>。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。</p>\n</blockquote>\n<p>首先看下Struts2中几个主要组件的示意图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Struts2组件示意图\"></p>\n<p>ActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的<strong>请求的生命周期</strong>可以泛指<strong>处理请求的线程的生命周期</strong>。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ActionContext implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    static ThreadLocal&lt;ActionContext&gt; actionContext = new ThreadLocal&lt;ActionContext&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    private Map&lt;String, Object&gt; context;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ActionContext(Map&lt;String, Object&gt; context) &#123;</span><br><span class=\"line\">        this.context = context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static ActionContext getContext() &#123;</span><br><span class=\"line\">        return actionContext.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Map&lt;String, Object&gt; getContextMap() &#123;</span><br><span class=\"line\">        return context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //。。。</span><br></pre></td></tr></table></figure>\n<p>ActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一<strong>解耦思路</strong>值得好好学习。Another brilliant idea！</p>\n<h4 id=\"2-2-1-Spring中thread-scope-Bean\"><a href=\"#2-2-1-Spring中thread-scope-Bean\" class=\"headerlink\" title=\"2.2.1 Spring中thread scope Bean\"></a>2.2.1 Spring中thread scope Bean</h4><p>在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容<br>易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SimpleThreadScope implements Scope &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope =</span><br><span class=\"line\">\t\t\tnew NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt;(&quot;SimpleThreadScope&quot;) &#123;</span><br><span class=\"line\">\t\t\t\t@Override</span><br><span class=\"line\">\t\t\t\tprotected Map&lt;String, Object&gt; initialValue() &#123;</span><br><span class=\"line\">\t\t\t\t\treturn new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123;</span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; scope = this.threadScope.get();</span><br><span class=\"line\">\t\tObject object = scope.get(name);</span><br><span class=\"line\">\t\tif (object == null) &#123;</span><br><span class=\"line\">\t\t\tobject = objectFactory.getObject();</span><br><span class=\"line\">\t\t\tscope.put(name, object);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn object;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p>上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种<strong>以空间换时间的思路</strong>，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>目录</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. ThreadLocal简介</span><br><span class=\"line\">    1.1 ThreadLocal基础</span><br><span class=\"line\">        1.1.1 ThreadLocal和Thread的关系</span><br><span class=\"line\">        1.1.2 变量的生命周期</span><br><span class=\"line\">    1.2 可继承的ThreadLocal</span><br><span class=\"line\">2. ThreadLocal的应用案例</span><br><span class=\"line\">    2.1 解决并发问题</span><br><span class=\"line\">        2.1.1 java.lang.ThreadLocalRandom</span><br><span class=\"line\">        2.1.2 HDFS中的Statistics：实现高并发下的统计功能</span><br><span class=\"line\">    2.2 解决数据存储问题</span><br><span class=\"line\">        2.2.1 Struts2的ActionContext设计原理</span><br><span class=\"line\">        2.2.2 Spring中thread scope Bean</span><br><span class=\"line\">3. 总结</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-ThreadLocal简介\"><a href=\"#1-ThreadLocal简介\" class=\"headerlink\" title=\"1. ThreadLocal简介\"></a>1. ThreadLocal简介</h2><blockquote>\n<p>这篇博客主要对ThreadLocal类的基础知识和实践应用进行分析。文章的重点在于应用案例的探究，同时也会对理论基础作简单的介绍。</p>\n</blockquote>\n<h3 id=\"1-1-ThreadLocal基础\"><a href=\"#1-1-ThreadLocal基础\" class=\"headerlink\" title=\"1.1 ThreadLocal基础\"></a>1.1 ThreadLocal基础</h3><h6 id=\"为什么需要ThreadLocal\"><a href=\"#为什么需要ThreadLocal\" class=\"headerlink\" title=\"为什么需要ThreadLocal\"></a>为什么需要ThreadLocal</h6><p>要理解为什么需要ThreadLocal就不得不从<strong>线程安全</strong>问题说起。高并发是很多领域都会遇到的非常棘手的问题，其最核心的问题在于<strong>如何平衡高性能和数据一致性</strong>。当我们说某个类是线程安全的时候，也就意味着该类在多线程环境下的状态保持一致性。</p>\n<blockquote>\n<p>所谓的<strong>一致性</strong>，就是关联数据之间的逻辑关系是否正确和完整。</p>\n</blockquote>\n<p>通过下面示例对数据一致性问题进行说明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalDemo &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\t\tint nThreads = 10;</span><br><span class=\"line\">\t\tfinal Counter counter = new Counter();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tExecutorService exec = Executors.newFixedThreadPool(nThreads);</span><br><span class=\"line\">\t\tfinal CountDownLatch latch = new CountDownLatch(nThreads);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tfor(int i = 0; i &lt; nThreads; i++)&#123;</span><br><span class=\"line\">\t\t\texec.submit(new Runnable()&#123;</span><br><span class=\"line\">\t\t\t\tpublic void run()&#123;</span><br><span class=\"line\">\t\t\t\t\tfor(int i = 0; i &lt; 10000; i++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tcounter.increase();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tlatch.countDown();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlatch.await();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;Expected:&quot; + nThreads * 10000 + &quot;,Actual:&quot; + counter.count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstatic class Counter&#123;</span><br><span class=\"line\">\t\tint count = 0;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tpublic void  increase()&#123;</span><br><span class=\"line\">\t\t\tthis.count++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Expected:100000,Actual:71851</p>\n</blockquote>\n<p>可见最终变量count的状态并不符合预期的逻辑。对于并发问题来说，最简单的解决办法就是<strong>加锁</strong>，本质是<strong>并发访问</strong>到<strong>串行访问</strong>的改变。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Counter&#123;</span><br><span class=\"line\">\tint count = 0;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic synchronized void  increase()&#123;</span><br><span class=\"line\">\t\tthis.count++;</span><br><span class=\"line\">\t&#125;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Expected:100000,Actual:100000</p>\n</blockquote>\n<p>第一次实验中，count变量的值之所以出现不正确的情况，是因为其被多个线程同时访问，而且对某个线程来说，其它线程对变量count的操作结果，该线程是不一定可见的，这是造成count变量最终数据不一致的原因。而用<strong>synchronized</strong>修饰过后，<strong>串行访问</strong>时就不存在不可见的情况。从而保证了count变量的正确性。那么是否可以换个思路：让变量只能被一个线程访问，这不就不存在之前谈到的线程安全问题了吗？</p>\n<blockquote>\n<p>让每个线程都保存一份变量的副本，该副本只会被隶属的线程操作，这也就不存在线程安全问题了。这就是ThreadLocal的由来。</p>\n</blockquote>\n<h4 id=\"1-1-1-ThreadLocal和Thread的联系\"><a href=\"#1-1-1-ThreadLocal和Thread的联系\" class=\"headerlink\" title=\"1.1.1 ThreadLocal和Thread的联系\"></a>1.1.1 ThreadLocal和Thread的联系</h4><p>在上面提到了<strong>数据副本</strong>,那么线程如何保存该副本的呢？其实，Thread类中有一个ThreadLocalMap类型的变量threadLocals，定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Thread implements Runnable &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = null;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ThreadLocalMap是ThreadLocal的一个内部类，其作用相当于一个HashMap，用于保存隶属于该线程的变量副本。下面需要考虑一个问题：<strong>ThreadLocalMap的key和value该如何设计呢？</strong></p>\n<p>从API角度来说，<strong>ThreadLocal的作用是提供给client访问Thread中threadLocals变量的访问接口</strong>，每个ThreadLocal都对应着一个Thread内部的变量副本。所以ThreadLocalMap中的<strong>key</strong>就是ThreadLocal对象（也就是该对象的hashCode），value也就是变量副本。一个对象默认的hashcode也就是该对象的引用值，这可以保证不同对象的hashcode不同。不过ThreadLocal并没有使用这一默认值，而是内部声明了一个threadLocalHashCode整型变量用以存储该对象的hashcode值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private final int threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static AtomicInteger nextHashCode =</span><br><span class=\"line\">        new AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static int nextHashCode() &#123;</span><br><span class=\"line\">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>变量副本</strong>的存储问题已经解决，那么怎么对Thread内部的threadLocals变量进行访问呢？这就要通过ThreadLocal了。下面对ThreadLocal的方法简单介绍下：</p>\n<ol>\n<li><p>get()操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public T get() &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();//获取当前Thread对象引用</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);//从Thread对象中获取ThreadLocalMap变量</span><br><span class=\"line\">    if (map != null) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class=\"line\">        if (e != null)</span><br><span class=\"line\">            return (T)e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return setInitialValue();//如果是第一次访问，就setInitialValue进行初始化</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private T setInitialValue() &#123;</span><br><span class=\"line\">    //initialValue方法是protected修饰的，默认返回null，所以需要在ThreadLocal子类中进行覆盖。</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    if (map != null)</span><br><span class=\"line\">        map.set(this, value);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">&#125;    </span><br></pre></td></tr></table></figure></li>\n<li><p>set操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void set(T value) &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    if (map != null)</span><br><span class=\"line\">        map.set(this, value);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和setInitialValue几乎一致，不同的是：set操作会传入需要设置的value。而setInitialValue需要通过initialValue()获取初始值。</p>\n</li>\n<li><p>remove操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void remove() &#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    if (m != null)</span><br><span class=\"line\">        m.remove(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-1-2-变量的生命周期\"><a href=\"#1-1-2-变量的生命周期\" class=\"headerlink\" title=\"1.1.2 变量的生命周期\"></a>1.1.2 变量的生命周期</h4><p>这里所的<strong>变量</strong>指的是存储在Thread对象中的变量副本。下面从init-service-destroy三个阶段分析下其生命周期:</p>\n</li>\n<li><p>Init<br>第一次调用get方法的时候完成了初始化过程。这也就是为什么需要覆盖ThreadLocal的initialValue方法。在setInitialValue方法中的createMap方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void createMap(Thread t, T firstValue) &#123;</span><br><span class=\"line\">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>Service<br>只要线程活着且ThreadLocal可访问即处于Service阶段。</p>\n</li>\n<li><p>Destroy<br>由于threadLocals变量是Thread的成员，那么当Thread对象挂了后，那么其内部的所有成员也都被gc了。此外，通过ThreadLocal提供remove方法也可以将threadLocals里的特定副本变量移除。</p>\n</li>\n</ol>\n<blockquote>\n<p>ThreadLocal变量的生命周期呢？由于ThreadLocal变量通常用private static修饰，也就是属于类成员<br>变量。所以其生命周期当然也就和该类一致。</p>\n</blockquote>\n<h3 id=\"1-2-可继承的ThreadLocal\"><a href=\"#1-2-可继承的ThreadLocal\" class=\"headerlink\" title=\"1.2 可继承的ThreadLocal\"></a>1.2 可继承的ThreadLocal</h3><p>首先看个实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Context &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate static final ThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT1 = new ThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class=\"line\">\t\tprotected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class=\"line\">\t\t\treturn new HashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tprivate static final InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt; CONTEXT2 = new InheritableThreadLocal&lt;HashMap&lt;String,String&gt;&gt;()&#123;</span><br><span class=\"line\">\t\tprotected HashMap&lt;String,String&gt; initialValue()&#123;</span><br><span class=\"line\">\t\t\treturn new HashMap&lt;String,String&gt;();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;\t\t</span><br><span class=\"line\">\tpublic static HashMap&lt;String,String&gt; getContext1() &#123;</span><br><span class=\"line\">\t\treturn CONTEXT1.get();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static HashMap&lt;String,String&gt; getContext2() &#123;</span><br><span class=\"line\">\t\treturn CONTEXT2.get();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class=\"line\">\tContext.getContext1().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class=\"line\">\tContext.getContext2().put(&quot;name&quot;, &quot;wqx&quot;);</span><br><span class=\"line\">\tThread thread = new Thread(new Runnable()&#123;</span><br><span class=\"line\">\t\t@Override</span><br><span class=\"line\">\t\tpublic void run() &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;name:&quot; + Context.getContext1().get(&quot;name&quot;));</span><br><span class=\"line\">\t\t\tSystem.out.println(&quot;name:&quot; + Context.getContext2().get(&quot;name&quot;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">\tthread.start();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>name:null</p>\n</blockquote>\n<blockquote>\n<p>name:wqx</p>\n</blockquote>\n<p>字面意思上理解InheritableThreadLocal即为可继承的ThreadLocal，这里的可继承的含义指的是子线程在实例化过程中，会查看当前执行线程（可以理解为父线程）的inheritableThreadLocals是否为null，如果不为null，则将该变量赋值给子线程的inheritableThreadLocals。下面是Thread类构造函数中的相关片段：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread parent = currentThread();//当前线程，也就是执行new Thread()的线程</span><br><span class=\"line\">if (parent.inheritableThreadLocals != null)</span><br><span class=\"line\">    this.inheritableThreadLocals =</span><br><span class=\"line\">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-ThreadLocal的应用案例\"><a href=\"#2-ThreadLocal的应用案例\" class=\"headerlink\" title=\"2. ThreadLocal的应用案例\"></a>2. ThreadLocal的应用案例</h2><h3 id=\"2-1-解决并发问题\"><a href=\"#2-1-解决并发问题\" class=\"headerlink\" title=\"2.1 解决并发问题\"></a>2.1 解决并发问题</h3><h4 id=\"2-1-1-java-lang-ThreadLocalRandom\"><a href=\"#2-1-1-java-lang-ThreadLocalRandom\" class=\"headerlink\" title=\"2.1.1 java.lang.ThreadLocalRandom\"></a>2.1.1 java.lang.ThreadLocalRandom</h4><p>在Java中随机数可以用Random类，下面是java.util.Random的生成随机数的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected int next(int bits) &#123;</span><br><span class=\"line\">    long oldseed, nextseed;</span><br><span class=\"line\">    AtomicLong seed = this.seed;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        oldseed = seed.get();</span><br><span class=\"line\">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class=\"line\">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class=\"line\">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见，其中通过CAS方式保证其线程安全性。这在高并发的环境中由于线程间的竞争必然带来一定的性能损耗。ThreadLocal此时就派上用场了，ThreadLocalRandom是通过ThreadLocal改进的用于随机数生成的工具类，每个线程单独持有一个ThreadLocalRandom对象引用，这就完全杜绝了线程间的竞争问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalRandom extends Random &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    private static final ThreadLocal&lt;ThreadLocalRandom&gt; localRandom =</span><br><span class=\"line\">        new ThreadLocal&lt;ThreadLocalRandom&gt;() &#123;</span><br><span class=\"line\">            protected ThreadLocalRandom initialValue() &#123;</span><br><span class=\"line\">                return new ThreadLocalRandom();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadLocalRandom能用于全局范围的随机数生成吗？每个线程都持有一个ThreadLocalRandom对象，生成的随机数不会重复吗？考虑到ThreadLocal的特点，理论上也就不应该将其用于全局范围，其更适合于线程独享变量的存储。But！凡事都有例外，下面看个例外的用法。</p>\n</blockquote>\n<h4 id=\"2-1-2-HDFS中的Statistics：实现高并发下的统计功能\"><a href=\"#2-1-2-HDFS中的Statistics：实现高并发下的统计功能\" class=\"headerlink\" title=\"2.1.2 HDFS中的Statistics：实现高并发下的统计功能\"></a>2.1.2 HDFS中的Statistics：实现高并发下的统计功能</h4><p>Hadoop的分布式文件系统（HDFS）是其生态的基石，MR任务中涉及到的数据输入输出都与其密切相关。对于FileSystem来说，对大量的读写操作进行统计是非常必要的。这该如何实现呢？</p>\n<blockquote>\n<p>方案一：通过加锁的方式。考虑到Hadoop处理的数据体量及对数据操作的频率，加锁带来的性能损耗不可忽视，So。。。PASS！</p>\n</blockquote>\n<blockquote>\n<p>方案二：ThreadLocal可以吗？对当前FileSystem进行操作的线程很多，如果只使用ThreadLocal方案的话，只能统计一个线程的操作次数，那么在汇总操作的时候必然要进行同步synchronized处理。这可行吗？判断一个方案可不可行，必须要具体业务逻辑具体分析，在本例中，statistics是用于存储<strong>统计数据</strong>的对象，那么对FileSystem进行操作（比如：create、mkdir、list、delete等）的同时都会记录在statistics对象中，也就是对statistics对象进行写操作，而对于统计数据的读操作比较少。所以Hadoop考虑到<strong>写多读少</strong>的事实，ThreadLocal方案是可以接受的。</p>\n</blockquote>\n<p>下面是Statistics对象的部分实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final class Statistics &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Statistics data.</span><br><span class=\"line\">     * /</span><br><span class=\"line\">    public static class StatisticsData &#123;</span><br><span class=\"line\">      volatile long bytesRead;</span><br><span class=\"line\">      volatile long bytesWritten;</span><br><span class=\"line\">      volatile int readOps;</span><br><span class=\"line\">      volatile int largeReadOps;</span><br><span class=\"line\">      volatile int writeOps;</span><br><span class=\"line\">      //。。。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //allData保存的是所有线程中StatisticsData对象的引用</span><br><span class=\"line\">    private final Set&lt;StatisticsDataReference&gt; allData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //ThreadLocal变量</span><br><span class=\"line\">    private final ThreadLocal&lt;StatisticsData&gt; threadData;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public void incrementBytesWritten(long newBytes) &#123;</span><br><span class=\"line\">      getThreadStatistics().bytesWritten += newBytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public StatisticsData getThreadStatistics() &#123;</span><br><span class=\"line\">      StatisticsData data = threadData.get();</span><br><span class=\"line\">      if (data == null) &#123;   //第一次统计操作时需要进行初始化，并与allData进行关联</span><br><span class=\"line\">        data = new StatisticsData();</span><br><span class=\"line\">        threadData.set(data);</span><br><span class=\"line\">        StatisticsDataReference ref =</span><br><span class=\"line\">            new StatisticsDataReference(data, Thread.currentThread());</span><br><span class=\"line\">        synchronized(this) &#123;</span><br><span class=\"line\">          allData.add(ref);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      return data;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是DistributedFileSystem中删除操作的实现，可见在每次执行删除操作的时候，都会通过statistics进行记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DistributedFileSystem extends FileSystem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  @Override</span><br><span class=\"line\">  public boolean delete(Path f, final boolean recursive) throws IOException &#123;</span><br><span class=\"line\">    statistics.incrementWriteOps(1);</span><br><span class=\"line\">    // 。。。</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果需要获取统计数据时，就要将所有线程内部的统计数据进行累加，这肯定需要进行同步处理的。如下所示的是获取统计数据中所有写操作的次数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long getBytesWritten() &#123;</span><br><span class=\"line\">  return visitAll(new StatisticsAggregator&lt;Long&gt;() &#123;</span><br><span class=\"line\">    private long bytesWritten = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void accept(StatisticsData data) &#123;</span><br><span class=\"line\">      bytesWritten += data.bytesWritten;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Long aggregate() &#123;</span><br><span class=\"line\">      return bytesWritten;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//加锁处理，保证统计数据的正确性</span><br><span class=\"line\">private synchronized &lt;T&gt; T visitAll(StatisticsAggregator&lt;T&gt; visitor) &#123;</span><br><span class=\"line\">  visitor.accept(rootData);</span><br><span class=\"line\">  for (StatisticsDataReference ref: allData) &#123;</span><br><span class=\"line\">    StatisticsData data = ref.getData();</span><br><span class=\"line\">    visitor.accept(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return visitor.aggregate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在写多读少的环境下，这种方案可以有效的解决传统“加锁”方案带来的多线程间的竞争。Brilliant idea！</p>\n<h3 id=\"2-2-解决数据存储问题\"><a href=\"#2-2-解决数据存储问题\" class=\"headerlink\" title=\"2.2 解决数据存储问题\"></a>2.2 解决数据存储问题</h3><h4 id=\"2-2-1-Struts2的ActionContext设计原理\"><a href=\"#2-2-1-Struts2的ActionContext设计原理\" class=\"headerlink\" title=\"2.2.1 Struts2的ActionContext设计原理\"></a>2.2.1 Struts2的ActionContext设计原理</h4><p>Struts2是使用较为广泛的MVC框架，其关于请求响应流程的设计思路也是很新颖的。当第一次接触Struts2的时候，曾一直困惑于一个问题：<strong>Action中的每个方法的请求参数怎么获得的</strong>?<strong>处理结果又是如何返回的</strong>?在传统的Servlet中，我们可以通过函数入参HttpServletRequest对象获取请求参数，可以通过入参HttpServletResponse对象向输出流写入响应数据。而Struts2中自定义的Action的每个方法都没有入参，且处理后的响应数据也不是当作返回值返回的。</p>\n<blockquote>\n<p>Struts2的<strong>最大亮点也许就是对数据流和控制流的解耦</strong>。数据不再需要作为方法参数传入或作为返回值返回。Struts2的返回值仅仅作为控制流的标识（比如：选择哪个视图）。Struts2中数据载体就是ActionContext。不管是请求参数亦或是处理后的响应数据都被封装在ActionContext内部。开发者一般常接触的是ActionContext的子类ServletActionContext。</p>\n</blockquote>\n<p>首先看下Struts2中几个主要组件的示意图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2599999-651c2e2c3c361d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Struts2组件示意图\"></p>\n<p>ActionContext作为数据载体，与每个组件都会有数据交互，如：ActionInvocation、Interceptor、Action、Result等。这几乎涵盖了一个请求的整个生命周期。这里说的<strong>请求的生命周期</strong>可以泛指<strong>处理请求的线程的生命周期</strong>。ThreadLocal不正适合这种情况吗？下面看下com.opensymphony.xwork2.ActionContext类的部分结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ActionContext implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    static ThreadLocal&lt;ActionContext&gt; actionContext = new ThreadLocal&lt;ActionContext&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    private Map&lt;String, Object&gt; context;</span><br><span class=\"line\"></span><br><span class=\"line\">    public ActionContext(Map&lt;String, Object&gt; context) &#123;</span><br><span class=\"line\">        this.context = context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static ActionContext getContext() &#123;</span><br><span class=\"line\">        return actionContext.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Map&lt;String, Object&gt; getContextMap() &#123;</span><br><span class=\"line\">        return context;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //。。。</span><br></pre></td></tr></table></figure>\n<p>ActionContext是典型的ThreadLocal使用案例，通过将请求处理过程中涉及到的所有参数封装进ActionContext中，从而实现了数据流和控制流的分离，这一<strong>解耦思路</strong>值得好好学习。Another brilliant idea！</p>\n<h4 id=\"2-2-1-Spring中thread-scope-Bean\"><a href=\"#2-2-1-Spring中thread-scope-Bean\" class=\"headerlink\" title=\"2.2.1 Spring中thread scope Bean\"></a>2.2.1 Spring中thread scope Bean</h4><p>在Spring中，如果按照Bean的生命周期对其进行划分，那么大致可以分为这么几类：Singleton、Prototype、Request、Session、Thread Scope等。这一节主要介绍ThreadScope的Bean如何实现。经过上面的各种案例分析，这个问题就灰常容<br>易解决了，只需要将Bean的生命周期与Thread同步就行。ThreadLocal正合适。下面是Spring内部已经实现的方案SimpleThreadScope：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SimpleThreadScope implements Scope &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope =</span><br><span class=\"line\">\t\t\tnew NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt;(&quot;SimpleThreadScope&quot;) &#123;</span><br><span class=\"line\">\t\t\t\t@Override</span><br><span class=\"line\">\t\t\t\tprotected Map&lt;String, Object&gt; initialValue() &#123;</span><br><span class=\"line\">\t\t\t\t\treturn new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123;</span><br><span class=\"line\">\t\tMap&lt;String, Object&gt; scope = this.threadScope.get();</span><br><span class=\"line\">\t\tObject object = scope.get(name);</span><br><span class=\"line\">\t\tif (object == null) &#123;</span><br><span class=\"line\">\t\t\tobject = objectFactory.getObject();</span><br><span class=\"line\">\t\t\tscope.put(name, object);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn object;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><p>上面小节中分别分析了ThreadLocal的两个主要的应用领域：1.解决并发问题。2.解决数据存储问题。其中解决并发问题的本质是一种<strong>以空间换时间的思路</strong>，时间效率提升了，但是也存在着内存使用时的潜在溢出风险。数据存储问题主要指的是：系统中多个组件如何实现数据的交互和共享，而作为执行者的线程作为数据载体再适合不过了。虽然各种组件可以实现数据共享，但是数据在线程间是隔离的。</p>\n"},{"title":"Web开发中的乱码问题","toc":true,"_content":"\n###### 主要内容\n```\n1. 字符编码理论简述\n    1.1 ASCII\n    1.2 ISO8859-1\n    1.3 Unicode\n    1.4 GBK\n    \n2. 可能发生的中文乱码\n    2.1 中文变问号，如：???\n    2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\n    2.3 中文变“复杂中文”，如：浣犲ソ\n    2.4 中文变成一堆黑色菱形+问号，如：�����\n\n3. Web开发中涉及到的中文编解码\n    3.1 URL中出现的中文\n    3.2 Form表单中出现的中文\n    3.3 JSP中涉及的编码\n    3.4 文件的上传和下载中涉及到的中文乱码\n4. 总结\n```\n## 1. 字符编码理论简述\n本文主要是围绕Web开发中涉及到的中文编码这一常见问题展开，包括了对字符编码基础理论的简述以及常见几种编码标准的介绍。其中包括：ASCII、ISO8859-1、Unicode、GBK。下面先对这些字符编码集进行简单的介绍。\n\n#### 1.1 ASCII\nASCII也就是美国信息交换标准码，采用单字节编码方案，但是编码只用了后七位字节，表示范围0-127共128个字符。ASCII码相对于其它编码也是最早出现的。从上世纪60年代提出开始，到1986年最终定型。\n\n> 为什么选择7位编码?ASCII在最初设计的时候需要至少能表示64个码元：包括26个字母+10个数字+图形标示+控制字符，如果用6bit编码，可扩展部分没有了，所以至少需要7bit。那么8bit呢？最终也被标准委员会否定，原因很简单：满足编码需求的前提下，最小化传输开销。\n\n####  1.2 ISO8859-1\nISO-8859-1也被称为Latin1，使用单字节8bit编码，可以表示256个西欧字符。其隶属于ISO8859标准的一部分，还有ISO8859-2、ISO8859-3等等。每一种编码都对应一个地区的字符集。比如：ISO8859-1表示西欧字符，ISO-8859-16表示中欧字符集，等等。\n\n####  1.3 Unicode\n不管是ASCII还是ISO8859-1，其编码范围都是有局限的。而Unicode标准的目标就是消除传统编码的**局限性**。\n\n> 这里的局限性一方面指编码范围的局限性：比如ASCII只能表示128个字符。还有编码兼容性方面的局限性：比如ISO8859代表的一系列编码字符集虽然可以表示大部分国家地区的字符，但是彼此的兼容性做的不好。Unicode的目标就如同其名称的含义一样：“实现字符编码统一”\n\n> Unicode标准的实现方案有如下三种：**UTF-8**、**UTF-16和**UTF-32**.\n\n**UTF-8**是变长编码，使用1到4个字节。UTF-8在设计时考虑到向前兼容，所以其前128个字符和ASCII完全一样，也就是说，所有ASCII同时也都符合UTF-8编码格式。其格式如下：\n```\n0xxxxxxx\n110xxxxx \t10xxxxxx\n1110xxxx \t10xxxxxx \t10xxxxxx\n11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n```\n字节首部为0的话，也就是前面说的ASCII了。此外，字节**首部连续1的个数**就代表了该字符编码后所占的字节数。目前全世界的网页编码绝大多数使用的就是UTF-8，占比接近90%。\n\n**UTF-16**也是变长编码，但其最初是**固定16-bit宽度的定长编码**，主要因为Unicode涵盖的字符太多了。两字节更本不够用！\n\n**UTF-32**是32-bit定长编码，优点：定长编码在处理效率上相对于变长编码要高，此外，可通过**索引**访问任意字符是其另一大优势；缺点也很明显：32bit太浪费了！存储效率太低！\n\n> big-endian和little-endian？在多字节编码标准中可能会遇到这样的问题：假如一个字符用两个字节表示，那么当读取这个字符的时候，哪个字节表示高有效位？哪个表示低有效位呢？这就涉及到字节的存储顺序问题。在Unicode中UTF-16和UTF-32都会面临这个问题。通常用BOM（Byte Order Mark）来进行区分。BOM用一个\"U+FEFF\"来表示，这个值在\nUnicode中是没有对应字符的。不仅可以用其来指定字节顺序，还可以表示字节流的编码方式。\n\n```\nSystem.out.println(\"len1:\" + \"a\".getBytes(\"UTF16\").length);\nSystem.out.println(\"len2:\" + \"aa\".getBytes(\"UTF16\").length);\n```\n输出结果：\n> len1:4\n\n> len2:6\n\n为什么是4和6，**不应该是2和4吗！？**。输出编码后的字节序列可以发现，起始的两个字节都是：\"fe ff\"。\n\n\n> Java的char类型用什么编码格式？Java语言规范规定了Java的char类型使用的是UTF-16。这就是为什么Java的char占用两个字节的原因。此外，Java标准库实现的对char与String的序列化规定使用UTF-8。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16，当然，在设计java的时候UTF-16还是定长的）与外部存储的空间效率（采用变长的UTF-8编码）而做的取舍。\n\n####  1.4 GBK\nGBK是用于对简体中文进行编码。每个字符用两字节表示，同时兼容GB2312标准。\n\n## 2. 可能发生的中文乱码\n这一小节介绍软件开发中常见的中文编码乱码问题，在下面示例中：对于给定的一个包含中文的字符串\"你好Java\"，看一下都会出现哪些乱码问题。\n\n#### 2.1 中文变问号，如：?????\n```\n\"你好Java\"  ------>  \"??Java\"\n```\n这种情况一般是由于**中文字符经ISO8859-1编码造成的。**下面是编码的具体过程：\n\n原字符串：\"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\n经ISO8859-1编码后：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n3f | 3f | 4a| 61| 76| 61\n\n编码后字符串：\"??Java\"\n```\nString str = \"你好Java\";\nSystem.out.println(byteToHexString(str.getBytes(CHARSET_ISO88591)));\nSystem.out.println(new String(str.getBytes(CHARSET_ISO88591)));\n输出：\n3f 3f 4a 61 76 61\n??Java\n```\n我们知道ISO8859-1是单字节编码，而对于汉字已经超出ISO8859-1的编码范围，会被转化为\"3f\"，我们查表可知，\"3f\"对应的字符正是\"?\"。\n\n> 中文变问号的乱码情况是非常常见的，大部分开源软件的默认编码设置成了ISO8859-1，这点需要格外注意。\n\n#### 2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\n```\n\"你好Java\"  ------>  \"ä½ å¥½Java\"\n```\n原字符串：\"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\n经UTF-8编码后，一个中文用三个字节表示：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---|---|---\ne4 bd a0 | e5 a5 bd | 4a| 61| 76| 61\n\n> 乱码原因：UTF8编码或GBK编码，再由ISO8859-1解码。对照ISO8859-1编码表后发现：e4 bd a0分别对应三个字符：\"ä½ \",e5 a5 bd分别对应三个字符\"å¥½\",\n\n#### 2.3 中文变“复杂中文”如：浣犲ソ\n下面依然是\"你好Java\"经过UTF-8编码后对应的字节序列：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---|---|---\ne4 bd a0 | e5 a5 bd | 4a| 61| 76| 61\n\n在GBK表中查找：e4 bd对应字符：\"浣\",a0 e5对应字符：\"犲\",a5 bd对应字符：\"ソ\"\n\n> 同理，如果GBK编码的中文用UTF-8来解码的话，同样会出现乱码问题。\n\n#### 2.4 中文变成一堆黑色菱形+问号，如：�����\n首先问号+黑色菱形的字符是Unicode中的\"REPLACEMENT CHARACTER\",该字符的主要作用是用来表示不识别的字符。\n所以产生乱码的原因可能有很多，下面通过原字符串：\"你好Java\"，重现一种乱码方式：\n```\n原字符串：String str = \"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\nUTF-16编码后\n\nfe ff 4f 60 59 7d 0 4a 0 61 0 76 0 61\n```\n其中\"fe ff\"就是字节流起始的BOM标识符。\"fe ff\"在Unicode标准中属于\"noncharacters\",只用于内部使用。所以，\n在输出该字节序列的时候，没有该码元对应的字符，对于不识别字符，就会用��替代。\n\n## 3. Web开发中涉及到的中文编解码\nWeb中的数据大多通过http协议进行传输，所涉及到的一些编解码问题都围绕着http协议。下面以Tomcat作为Web服务器，\n探讨下一个完整的请求响应流程中哪些地方会涉及到中文的编解码。\n#### 3.1 url编解码\nweb环境中的中文乱码问题，实验如下：\n```\njsp中的form表单：\n<body>\n\t<form name=\"form\" method=\"post\" action=\"manager/codec/你好\">\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<td>用户名： <input type=\"text\" name=\"name\" id=\"name\" />\n\t\t\t\t</td>\n\t\t\t\t<td>地址 <input type=\"text\" name=\"address\" id=\"address\" />\n\t\t\t\t</td>\n\t\t\t\t<th><input type=\"submit\" name=\"submit\" value=\"保存\" /></th>\n\t\t\t</tr>\n\t\t</table>\n\t</form>\n</body>\n\n后端使用SpringMVC的Controller：\n\n@Controller()\n@RequestMapping(\"/manager\")\npublic class ManagerController {\n\n    @RequestMapping(\"/test/{param}\")\n    @ResponseBody\n    public String test(@PathVariable String param, HttpServletRequest request){\n        String name = request.getParameter(\"name\");\n        System.out.println(\"name:\" + name + \",param:\" + param);\n        return \"test\";\n    }\n}\n```\n表单中填入内容：\n用户名：你好 Java\n地址：123\n提交请求，firebug中的显示的url如下：\n\n> http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD\n\n查阅编码可以，firefox对url中出现的中文使用了UTF-8的编码方式。之所以url中出现%，这是因为根据URL编码规范，浏览器会将非ASCII字符编成16进制后，每个字节前需要加%。\n\n后端控制台输出：\n```\nname:ä½ å¥½ Java,param:ä½ å¥½\n```\n\n可见无论是url中的中文信息或是post表单中的中文都出现了乱码现象，从前一节中关于乱码情况的分析来看，这里应该是**中文字符经过浏览器UTF-8编码后，Server端用ISO8859-1进行解码所致。**下面逐个分析url和post表单如何进行编解码的。\n\n在tomcat中url的byte -> char的转换是在org.apache.catalina.connector.CoyoteAdapter类的convertURI(MessageBytes uri, Request request)方法中执行的，源码如下：\n\n```\n    protected void convertURI(MessageBytes uri, Request request)throws Exception {\n\n        ByteChunk bc = uri.getByteChunk();\n        int length = bc.getLength();\n        CharChunk cc = uri.getCharChunk();\n        cc.allocate(length, -1);\n    \n//这里获取的connector的URIEncoding属性，即server.xml文件中connector元素的URIEncoding属性\n        String enc = connector.getURIEncoding();\n        if (enc != null) {\n            B2CConverter conv = request.getURIConverter();\n            try {\n                if (conv == null) {\n                    conv = new B2CConverter(enc, true);\n                    request.setURIConverter(conv);\n                } else {\n                    conv.recycle();\n                }\n            } catch (IOException e) {\n                log.error(\"Invalid URI encoding; using HTTP default\");\n                connector.setURIEncoding(null);\n            }\n            if (conv != null) {\n                try {\n                    conv.convert(bc, cc, true);\n                    uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength());\n                    return;\n                } catch (IOException ioe) {\n                    request.getResponse().sendError(\n                            HttpServletResponse.SC_BAD_REQUEST);\n                }\n            }\n        }\n\n        // 如果没有配置URIEncoding，则在ByteChunk中默认使用ISO8859-1。\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        uri.setChars(cbuf, 0, length);\n    }\n```\n在org.apache.tomcat.util.buf.ByteChunk中可以看到默认编码的定义：\n```\npublic final class ByteChunk implements Cloneable, Serializable {\n\n    //。。。\n    \n    public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1;\n    \n    //。。。\n}\n```\n所以对于请求url中的中文，我们按UTF-8进行编码，在服务端却按ISO8859-1进行解码，所以出现乱码现象。我们可以再Tomcat的server.xml中指定url的编解码格式，如下：\n```\n<Connector  URIEncoding=\"UTF-8\" 。。。>\n\n```\n> 此时重复上面实验，后端控制台输出：name:ä½ å¥½ Java,param:你好\n\n虽然url中的参数可以正常显示了，但是form表单中的参数name依然乱码，下面进一步分析。\n### 3.2 form表单元素的编解码\nname参数的编码依然是乱码的，为啥？首先**定位form表单中参数是在哪里进行解码的。**Form表单中的字符解码时机是发生在第一次调用request.getParameter时，可以通过request.setCharacterEncoding设置。**需要注意的是setCharacterEncoding必须在getParameter之前调用！否则，setCharacterEncoding不会起作用。**\n\nTomcat中HttpServletRequest接口的实现类是**org.apache.catalina.connector.Request**。下面是Request类中getParameter源码：\n```\n    @Override\n    public String getParameter(String name) {\n        //判断参数是否被解析过\n        if (!parametersParsed) {\n            parseParameters();//第一次参数解析\n        }\n        \n        return coyoteRequest.getParameters().getParameter(name);\n    }\n\n//下面是parseParameters部分源码\n\n   protected void parseParameters() {\n        \n        //设为true，表示参数已解析过\n        parametersParsed = true;\n        //Parameters对象封装了form表单参数\n        Parameters parameters = coyoteRequest.getParameters();\n        \n        boolean success = false;\n        try {\n            // Set this every time in case limit has been changed via JMX\n            parameters.setLimit(getConnector().getMaxParameterCount());\n        \n            //获取字符编码格式\n            String enc = getCharacterEncoding();\n\n            boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();\n            if (enc != null) {\n            //getCharacterEncoding不为null，则对应设置编码方式\n                parameters.setEncoding(enc);\n                if (useBodyEncodingForURI) {\n                    parameters.setQueryStringEncoding(enc);\n                }\n            } else {\n                //如果enc为null，则编码方式设置为DEFAULT_CHARACTER_ENCODING，也就是ISO8859-1\n                parameters.setEncoding\n                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);\n                if (useBodyEncodingForURI) {\n                    parameters.setQueryStringEncoding\n                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);\n                }\n            }\n\n            parameters.handleQueryParameters();\n            \n            。。。\n        }\n    }\n```\n从以上源码中可以看出为什么需要在第一次调用getParameter之前设置CharacterEncoding。因为第一次执行parseParameters时，会把parametersParsed变量设为true。所以parseParameters只会在第一次getParameter时调用。有时会出现这么一种怪像：通过request.getCharacterEncoding()得到的是我们认为正确的编码字符集，但是request.getParameter得到的依然是乱码。此时就需要考虑下我们调用setCharacterEncoding之前是否已经调用过getParameter方法了。\n\n> 经过上面的分析后，对于form表单参数乱码问题就很好解决了，在第一次调用request.getParameter方法前，通过request.setCharacterEncoding(\"Expected_Encoding\");设置即可。这一步可以用Servlet标准中的Filter实现，不过，常用的MVC框架中已经有现成的Filter实现了，比如SpringMVC中的org.springframework.web.filter.CharacterEncodingFilter,如下：\n\n```\n\t@Override\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.encoding != null && (this.forceEncoding || request.getCharacterEncoding() == null)) {\n\t\t\trequest.setCharacterEncoding(this.encoding);//设置指定的编码\n\t\t\tif (this.forceEncoding) {\n\t\t\t\tresponse.setCharacterEncoding(this.encoding);\n\t\t\t}\n\t\t}\n\t\tfilterChain.doFilter(request, response);\n\t}\n```\n### 3.3 JSP中涉及的编码\njsp中可以通过page指令指定一些编码参数，如下：\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n\tpageEncoding=\"UTF-8\"%>\n```\n###### pageEncoding=\"UTF-8\"在什么时候起作用？\n在Servlet标准中，jsp最终也会被编译成一个servlet。**index.jsp->index_jsp.java**.pageEncoding=\"UTF-8\"就是在这个解析过程中起作用的。\n\n###### contentType=\"text/html; charset=UTF-8\"的作用？\ncontentType是响应头中特定信息，主要的作用是告诉浏览器response中存放的主体对象类型和编码，这样浏览器就可以对指定类型进行正确解码，保证了数据在server和client端的一致性。当进行Servlet编程的时候，可以手动进行设置，如下：\n```\nresponse.setContentType(\"text/html; charset=UTF-8\");\n```\n### 3.4 文件的上传和下载中涉及到的中文乱码\nWeb中的文件操作主要是上传和下载，这个过程也是依托于Http协议作为数据载体。所以，最终是否乱码重点在于是否正确的设置http的request、response的header中的相关字段。如ContentType、Content-Disposition的设定等。如下：\n```\nresponse.setHeader(\"Pragma\", \"no-cache\");\nresponse.setHeader(\"Cache-Control\", \"no-cache\");\nresponse.setDateHeader(\"Expires\", 0);\nresponse.setContentType(\"application/x-msdownload\");\nresponse.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n```\n这里需要注意的是**Content-Disposition**的filename属性值，如果fileName含有中文，那么要格外注意fileName字符串的编码格式。在[rfc5987](https://tools.ietf.org/html/rfc5987)对于HTTP的Header中参数的编码做出了明确的规定：\n> By default, message header field parameters in Hypertext Transfer  Protocol (HTTP) messages cannot carry characters outside the ISO-8859-1 character set.\n\n也就是说默认情况下，Http的Header中的参数只能用ISO-8859-1字符集中的字符，那么是否意味着Content-Disposition中的fileName字符串也要转成ISO-8859-1了呢？答案是：NO！原因如下：Content-Disposition其实不属于Http/1.1标准。这在[RFC2616](https://tools.ietf.org/html/rfc2616#section-15.5)中有明确的说明。只因为其使用广泛，HTTP才对其支持。在[rfc6266](https://tools.ietf.org/html/rfc6266#section-4.3)中也详细介绍了Content-Disposition的filename参数含义和用法。下面是对于下载包含中文名称的文件时的解决方案。\n\n###### 解决方案\n最简单就是直接用ISO8859-1对文件名进行编码，大多数浏览器都支持。如下：\n```\nexportFileName.getBytes(\"UTF-8\"),\"ISO8859-1\");//这里的UTF-8也可能是别的编码，主要依据系统默认的编码来设定。\n```\n或通过其它编码，如UTF-8。\n```\nresponse.addHeader(\"Content-Disposition\",\n                \"attachment; filename*=UTF-8''\" + URLEncoder.encode(exportFileName, \"UTF8\"));\n```\n\n## 4. 总结\n编解码问题是多语言交互系统中必然要面对的问题，尤其对于中文环境中的开发者来说，在入门阶段或多或少都会遇到此类问题。乱码问题本质就是通信双方使用的标准不一致。所以，解决乱码问题的方法其实也很简单，统一下编解码标准即可。此外，深入理解各种编码标准的原理和关系也非常重要，在以后遇到类似问题的时候能够更加准确的判断出造成乱码的原因。","source":"_posts/Web开发中的乱码问题.md","raw":"---\ntitle: Web开发中的乱码问题\ntoc: true\n---\n\n###### 主要内容\n```\n1. 字符编码理论简述\n    1.1 ASCII\n    1.2 ISO8859-1\n    1.3 Unicode\n    1.4 GBK\n    \n2. 可能发生的中文乱码\n    2.1 中文变问号，如：???\n    2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\n    2.3 中文变“复杂中文”，如：浣犲ソ\n    2.4 中文变成一堆黑色菱形+问号，如：�����\n\n3. Web开发中涉及到的中文编解码\n    3.1 URL中出现的中文\n    3.2 Form表单中出现的中文\n    3.3 JSP中涉及的编码\n    3.4 文件的上传和下载中涉及到的中文乱码\n4. 总结\n```\n## 1. 字符编码理论简述\n本文主要是围绕Web开发中涉及到的中文编码这一常见问题展开，包括了对字符编码基础理论的简述以及常见几种编码标准的介绍。其中包括：ASCII、ISO8859-1、Unicode、GBK。下面先对这些字符编码集进行简单的介绍。\n\n#### 1.1 ASCII\nASCII也就是美国信息交换标准码，采用单字节编码方案，但是编码只用了后七位字节，表示范围0-127共128个字符。ASCII码相对于其它编码也是最早出现的。从上世纪60年代提出开始，到1986年最终定型。\n\n> 为什么选择7位编码?ASCII在最初设计的时候需要至少能表示64个码元：包括26个字母+10个数字+图形标示+控制字符，如果用6bit编码，可扩展部分没有了，所以至少需要7bit。那么8bit呢？最终也被标准委员会否定，原因很简单：满足编码需求的前提下，最小化传输开销。\n\n####  1.2 ISO8859-1\nISO-8859-1也被称为Latin1，使用单字节8bit编码，可以表示256个西欧字符。其隶属于ISO8859标准的一部分，还有ISO8859-2、ISO8859-3等等。每一种编码都对应一个地区的字符集。比如：ISO8859-1表示西欧字符，ISO-8859-16表示中欧字符集，等等。\n\n####  1.3 Unicode\n不管是ASCII还是ISO8859-1，其编码范围都是有局限的。而Unicode标准的目标就是消除传统编码的**局限性**。\n\n> 这里的局限性一方面指编码范围的局限性：比如ASCII只能表示128个字符。还有编码兼容性方面的局限性：比如ISO8859代表的一系列编码字符集虽然可以表示大部分国家地区的字符，但是彼此的兼容性做的不好。Unicode的目标就如同其名称的含义一样：“实现字符编码统一”\n\n> Unicode标准的实现方案有如下三种：**UTF-8**、**UTF-16和**UTF-32**.\n\n**UTF-8**是变长编码，使用1到4个字节。UTF-8在设计时考虑到向前兼容，所以其前128个字符和ASCII完全一样，也就是说，所有ASCII同时也都符合UTF-8编码格式。其格式如下：\n```\n0xxxxxxx\n110xxxxx \t10xxxxxx\n1110xxxx \t10xxxxxx \t10xxxxxx\n11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx\n```\n字节首部为0的话，也就是前面说的ASCII了。此外，字节**首部连续1的个数**就代表了该字符编码后所占的字节数。目前全世界的网页编码绝大多数使用的就是UTF-8，占比接近90%。\n\n**UTF-16**也是变长编码，但其最初是**固定16-bit宽度的定长编码**，主要因为Unicode涵盖的字符太多了。两字节更本不够用！\n\n**UTF-32**是32-bit定长编码，优点：定长编码在处理效率上相对于变长编码要高，此外，可通过**索引**访问任意字符是其另一大优势；缺点也很明显：32bit太浪费了！存储效率太低！\n\n> big-endian和little-endian？在多字节编码标准中可能会遇到这样的问题：假如一个字符用两个字节表示，那么当读取这个字符的时候，哪个字节表示高有效位？哪个表示低有效位呢？这就涉及到字节的存储顺序问题。在Unicode中UTF-16和UTF-32都会面临这个问题。通常用BOM（Byte Order Mark）来进行区分。BOM用一个\"U+FEFF\"来表示，这个值在\nUnicode中是没有对应字符的。不仅可以用其来指定字节顺序，还可以表示字节流的编码方式。\n\n```\nSystem.out.println(\"len1:\" + \"a\".getBytes(\"UTF16\").length);\nSystem.out.println(\"len2:\" + \"aa\".getBytes(\"UTF16\").length);\n```\n输出结果：\n> len1:4\n\n> len2:6\n\n为什么是4和6，**不应该是2和4吗！？**。输出编码后的字节序列可以发现，起始的两个字节都是：\"fe ff\"。\n\n\n> Java的char类型用什么编码格式？Java语言规范规定了Java的char类型使用的是UTF-16。这就是为什么Java的char占用两个字节的原因。此外，Java标准库实现的对char与String的序列化规定使用UTF-8。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16，当然，在设计java的时候UTF-16还是定长的）与外部存储的空间效率（采用变长的UTF-8编码）而做的取舍。\n\n####  1.4 GBK\nGBK是用于对简体中文进行编码。每个字符用两字节表示，同时兼容GB2312标准。\n\n## 2. 可能发生的中文乱码\n这一小节介绍软件开发中常见的中文编码乱码问题，在下面示例中：对于给定的一个包含中文的字符串\"你好Java\"，看一下都会出现哪些乱码问题。\n\n#### 2.1 中文变问号，如：?????\n```\n\"你好Java\"  ------>  \"??Java\"\n```\n这种情况一般是由于**中文字符经ISO8859-1编码造成的。**下面是编码的具体过程：\n\n原字符串：\"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\n经ISO8859-1编码后：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n3f | 3f | 4a| 61| 76| 61\n\n编码后字符串：\"??Java\"\n```\nString str = \"你好Java\";\nSystem.out.println(byteToHexString(str.getBytes(CHARSET_ISO88591)));\nSystem.out.println(new String(str.getBytes(CHARSET_ISO88591)));\n输出：\n3f 3f 4a 61 76 61\n??Java\n```\n我们知道ISO8859-1是单字节编码，而对于汉字已经超出ISO8859-1的编码范围，会被转化为\"3f\"，我们查表可知，\"3f\"对应的字符正是\"?\"。\n\n> 中文变问号的乱码情况是非常常见的，大部分开源软件的默认编码设置成了ISO8859-1，这点需要格外注意。\n\n#### 2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\n```\n\"你好Java\"  ------>  \"ä½ å¥½Java\"\n```\n原字符串：\"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\n经UTF-8编码后，一个中文用三个字节表示：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---|---|---\ne4 bd a0 | e5 a5 bd | 4a| 61| 76| 61\n\n> 乱码原因：UTF8编码或GBK编码，再由ISO8859-1解码。对照ISO8859-1编码表后发现：e4 bd a0分别对应三个字符：\"ä½ \",e5 a5 bd分别对应三个字符\"å¥½\",\n\n#### 2.3 中文变“复杂中文”如：浣犲ソ\n下面依然是\"你好Java\"经过UTF-8编码后对应的字节序列：\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---|---|---\ne4 bd a0 | e5 a5 bd | 4a| 61| 76| 61\n\n在GBK表中查找：e4 bd对应字符：\"浣\",a0 e5对应字符：\"犲\",a5 bd对应字符：\"ソ\"\n\n> 同理，如果GBK编码的中文用UTF-8来解码的话，同样会出现乱码问题。\n\n#### 2.4 中文变成一堆黑色菱形+问号，如：�����\n首先问号+黑色菱形的字符是Unicode中的\"REPLACEMENT CHARACTER\",该字符的主要作用是用来表示不识别的字符。\n所以产生乱码的原因可能有很多，下面通过原字符串：\"你好Java\"，重现一种乱码方式：\n```\n原字符串：String str = \"你好Java\"\n\n你 | 好 | J| a| v| a\n---|---|---|---|---|---\n4f60 | 597d | 4a| 61| 76| 61\n\nUTF-16编码后\n\nfe ff 4f 60 59 7d 0 4a 0 61 0 76 0 61\n```\n其中\"fe ff\"就是字节流起始的BOM标识符。\"fe ff\"在Unicode标准中属于\"noncharacters\",只用于内部使用。所以，\n在输出该字节序列的时候，没有该码元对应的字符，对于不识别字符，就会用��替代。\n\n## 3. Web开发中涉及到的中文编解码\nWeb中的数据大多通过http协议进行传输，所涉及到的一些编解码问题都围绕着http协议。下面以Tomcat作为Web服务器，\n探讨下一个完整的请求响应流程中哪些地方会涉及到中文的编解码。\n#### 3.1 url编解码\nweb环境中的中文乱码问题，实验如下：\n```\njsp中的form表单：\n<body>\n\t<form name=\"form\" method=\"post\" action=\"manager/codec/你好\">\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<td>用户名： <input type=\"text\" name=\"name\" id=\"name\" />\n\t\t\t\t</td>\n\t\t\t\t<td>地址 <input type=\"text\" name=\"address\" id=\"address\" />\n\t\t\t\t</td>\n\t\t\t\t<th><input type=\"submit\" name=\"submit\" value=\"保存\" /></th>\n\t\t\t</tr>\n\t\t</table>\n\t</form>\n</body>\n\n后端使用SpringMVC的Controller：\n\n@Controller()\n@RequestMapping(\"/manager\")\npublic class ManagerController {\n\n    @RequestMapping(\"/test/{param}\")\n    @ResponseBody\n    public String test(@PathVariable String param, HttpServletRequest request){\n        String name = request.getParameter(\"name\");\n        System.out.println(\"name:\" + name + \",param:\" + param);\n        return \"test\";\n    }\n}\n```\n表单中填入内容：\n用户名：你好 Java\n地址：123\n提交请求，firebug中的显示的url如下：\n\n> http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD\n\n查阅编码可以，firefox对url中出现的中文使用了UTF-8的编码方式。之所以url中出现%，这是因为根据URL编码规范，浏览器会将非ASCII字符编成16进制后，每个字节前需要加%。\n\n后端控制台输出：\n```\nname:ä½ å¥½ Java,param:ä½ å¥½\n```\n\n可见无论是url中的中文信息或是post表单中的中文都出现了乱码现象，从前一节中关于乱码情况的分析来看，这里应该是**中文字符经过浏览器UTF-8编码后，Server端用ISO8859-1进行解码所致。**下面逐个分析url和post表单如何进行编解码的。\n\n在tomcat中url的byte -> char的转换是在org.apache.catalina.connector.CoyoteAdapter类的convertURI(MessageBytes uri, Request request)方法中执行的，源码如下：\n\n```\n    protected void convertURI(MessageBytes uri, Request request)throws Exception {\n\n        ByteChunk bc = uri.getByteChunk();\n        int length = bc.getLength();\n        CharChunk cc = uri.getCharChunk();\n        cc.allocate(length, -1);\n    \n//这里获取的connector的URIEncoding属性，即server.xml文件中connector元素的URIEncoding属性\n        String enc = connector.getURIEncoding();\n        if (enc != null) {\n            B2CConverter conv = request.getURIConverter();\n            try {\n                if (conv == null) {\n                    conv = new B2CConverter(enc, true);\n                    request.setURIConverter(conv);\n                } else {\n                    conv.recycle();\n                }\n            } catch (IOException e) {\n                log.error(\"Invalid URI encoding; using HTTP default\");\n                connector.setURIEncoding(null);\n            }\n            if (conv != null) {\n                try {\n                    conv.convert(bc, cc, true);\n                    uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength());\n                    return;\n                } catch (IOException ioe) {\n                    request.getResponse().sendError(\n                            HttpServletResponse.SC_BAD_REQUEST);\n                }\n            }\n        }\n\n        // 如果没有配置URIEncoding，则在ByteChunk中默认使用ISO8859-1。\n        byte[] bbuf = bc.getBuffer();\n        char[] cbuf = cc.getBuffer();\n        int start = bc.getStart();\n        for (int i = 0; i < length; i++) {\n            cbuf[i] = (char) (bbuf[i + start] & 0xff);\n        }\n        uri.setChars(cbuf, 0, length);\n    }\n```\n在org.apache.tomcat.util.buf.ByteChunk中可以看到默认编码的定义：\n```\npublic final class ByteChunk implements Cloneable, Serializable {\n\n    //。。。\n    \n    public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1;\n    \n    //。。。\n}\n```\n所以对于请求url中的中文，我们按UTF-8进行编码，在服务端却按ISO8859-1进行解码，所以出现乱码现象。我们可以再Tomcat的server.xml中指定url的编解码格式，如下：\n```\n<Connector  URIEncoding=\"UTF-8\" 。。。>\n\n```\n> 此时重复上面实验，后端控制台输出：name:ä½ å¥½ Java,param:你好\n\n虽然url中的参数可以正常显示了，但是form表单中的参数name依然乱码，下面进一步分析。\n### 3.2 form表单元素的编解码\nname参数的编码依然是乱码的，为啥？首先**定位form表单中参数是在哪里进行解码的。**Form表单中的字符解码时机是发生在第一次调用request.getParameter时，可以通过request.setCharacterEncoding设置。**需要注意的是setCharacterEncoding必须在getParameter之前调用！否则，setCharacterEncoding不会起作用。**\n\nTomcat中HttpServletRequest接口的实现类是**org.apache.catalina.connector.Request**。下面是Request类中getParameter源码：\n```\n    @Override\n    public String getParameter(String name) {\n        //判断参数是否被解析过\n        if (!parametersParsed) {\n            parseParameters();//第一次参数解析\n        }\n        \n        return coyoteRequest.getParameters().getParameter(name);\n    }\n\n//下面是parseParameters部分源码\n\n   protected void parseParameters() {\n        \n        //设为true，表示参数已解析过\n        parametersParsed = true;\n        //Parameters对象封装了form表单参数\n        Parameters parameters = coyoteRequest.getParameters();\n        \n        boolean success = false;\n        try {\n            // Set this every time in case limit has been changed via JMX\n            parameters.setLimit(getConnector().getMaxParameterCount());\n        \n            //获取字符编码格式\n            String enc = getCharacterEncoding();\n\n            boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();\n            if (enc != null) {\n            //getCharacterEncoding不为null，则对应设置编码方式\n                parameters.setEncoding(enc);\n                if (useBodyEncodingForURI) {\n                    parameters.setQueryStringEncoding(enc);\n                }\n            } else {\n                //如果enc为null，则编码方式设置为DEFAULT_CHARACTER_ENCODING，也就是ISO8859-1\n                parameters.setEncoding\n                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);\n                if (useBodyEncodingForURI) {\n                    parameters.setQueryStringEncoding\n                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);\n                }\n            }\n\n            parameters.handleQueryParameters();\n            \n            。。。\n        }\n    }\n```\n从以上源码中可以看出为什么需要在第一次调用getParameter之前设置CharacterEncoding。因为第一次执行parseParameters时，会把parametersParsed变量设为true。所以parseParameters只会在第一次getParameter时调用。有时会出现这么一种怪像：通过request.getCharacterEncoding()得到的是我们认为正确的编码字符集，但是request.getParameter得到的依然是乱码。此时就需要考虑下我们调用setCharacterEncoding之前是否已经调用过getParameter方法了。\n\n> 经过上面的分析后，对于form表单参数乱码问题就很好解决了，在第一次调用request.getParameter方法前，通过request.setCharacterEncoding(\"Expected_Encoding\");设置即可。这一步可以用Servlet标准中的Filter实现，不过，常用的MVC框架中已经有现成的Filter实现了，比如SpringMVC中的org.springframework.web.filter.CharacterEncodingFilter,如下：\n\n```\n\t@Override\n\tprotected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.encoding != null && (this.forceEncoding || request.getCharacterEncoding() == null)) {\n\t\t\trequest.setCharacterEncoding(this.encoding);//设置指定的编码\n\t\t\tif (this.forceEncoding) {\n\t\t\t\tresponse.setCharacterEncoding(this.encoding);\n\t\t\t}\n\t\t}\n\t\tfilterChain.doFilter(request, response);\n\t}\n```\n### 3.3 JSP中涉及的编码\njsp中可以通过page指令指定一些编码参数，如下：\n```\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\n\tpageEncoding=\"UTF-8\"%>\n```\n###### pageEncoding=\"UTF-8\"在什么时候起作用？\n在Servlet标准中，jsp最终也会被编译成一个servlet。**index.jsp->index_jsp.java**.pageEncoding=\"UTF-8\"就是在这个解析过程中起作用的。\n\n###### contentType=\"text/html; charset=UTF-8\"的作用？\ncontentType是响应头中特定信息，主要的作用是告诉浏览器response中存放的主体对象类型和编码，这样浏览器就可以对指定类型进行正确解码，保证了数据在server和client端的一致性。当进行Servlet编程的时候，可以手动进行设置，如下：\n```\nresponse.setContentType(\"text/html; charset=UTF-8\");\n```\n### 3.4 文件的上传和下载中涉及到的中文乱码\nWeb中的文件操作主要是上传和下载，这个过程也是依托于Http协议作为数据载体。所以，最终是否乱码重点在于是否正确的设置http的request、response的header中的相关字段。如ContentType、Content-Disposition的设定等。如下：\n```\nresponse.setHeader(\"Pragma\", \"no-cache\");\nresponse.setHeader(\"Cache-Control\", \"no-cache\");\nresponse.setDateHeader(\"Expires\", 0);\nresponse.setContentType(\"application/x-msdownload\");\nresponse.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + fileName + \"\\\"\");\n```\n这里需要注意的是**Content-Disposition**的filename属性值，如果fileName含有中文，那么要格外注意fileName字符串的编码格式。在[rfc5987](https://tools.ietf.org/html/rfc5987)对于HTTP的Header中参数的编码做出了明确的规定：\n> By default, message header field parameters in Hypertext Transfer  Protocol (HTTP) messages cannot carry characters outside the ISO-8859-1 character set.\n\n也就是说默认情况下，Http的Header中的参数只能用ISO-8859-1字符集中的字符，那么是否意味着Content-Disposition中的fileName字符串也要转成ISO-8859-1了呢？答案是：NO！原因如下：Content-Disposition其实不属于Http/1.1标准。这在[RFC2616](https://tools.ietf.org/html/rfc2616#section-15.5)中有明确的说明。只因为其使用广泛，HTTP才对其支持。在[rfc6266](https://tools.ietf.org/html/rfc6266#section-4.3)中也详细介绍了Content-Disposition的filename参数含义和用法。下面是对于下载包含中文名称的文件时的解决方案。\n\n###### 解决方案\n最简单就是直接用ISO8859-1对文件名进行编码，大多数浏览器都支持。如下：\n```\nexportFileName.getBytes(\"UTF-8\"),\"ISO8859-1\");//这里的UTF-8也可能是别的编码，主要依据系统默认的编码来设定。\n```\n或通过其它编码，如UTF-8。\n```\nresponse.addHeader(\"Content-Disposition\",\n                \"attachment; filename*=UTF-8''\" + URLEncoder.encode(exportFileName, \"UTF8\"));\n```\n\n## 4. 总结\n编解码问题是多语言交互系统中必然要面对的问题，尤其对于中文环境中的开发者来说，在入门阶段或多或少都会遇到此类问题。乱码问题本质就是通信双方使用的标准不一致。所以，解决乱码问题的方法其实也很简单，统一下编解码标准即可。此外，深入理解各种编码标准的原理和关系也非常重要，在以后遇到类似问题的时候能够更加准确的判断出造成乱码的原因。","slug":"Web开发中的乱码问题","published":1,"date":"2021-12-13T03:18:46.953Z","updated":"2021-12-13T08:36:00.427Z","_id":"ckx4dd16r0001k60jf4in16gt","comments":1,"layout":"post","photos":[],"link":"","content":"<h6 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 字符编码理论简述</span><br><span class=\"line\">    1.1 ASCII</span><br><span class=\"line\">    1.2 ISO8859-1</span><br><span class=\"line\">    1.3 Unicode</span><br><span class=\"line\">    1.4 GBK</span><br><span class=\"line\">    </span><br><span class=\"line\">2. 可能发生的中文乱码</span><br><span class=\"line\">    2.1 中文变问号，如：???</span><br><span class=\"line\">    2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ</span><br><span class=\"line\">    2.3 中文变“复杂中文”，如：浣犲ソ</span><br><span class=\"line\">    2.4 中文变成一堆黑色菱形+问号，如：�����</span><br><span class=\"line\"></span><br><span class=\"line\">3. Web开发中涉及到的中文编解码</span><br><span class=\"line\">    3.1 URL中出现的中文</span><br><span class=\"line\">    3.2 Form表单中出现的中文</span><br><span class=\"line\">    3.3 JSP中涉及的编码</span><br><span class=\"line\">    3.4 文件的上传和下载中涉及到的中文乱码</span><br><span class=\"line\">4. 总结</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-字符编码理论简述\"><a href=\"#1-字符编码理论简述\" class=\"headerlink\" title=\"1. 字符编码理论简述\"></a>1. 字符编码理论简述</h2><p>本文主要是围绕Web开发中涉及到的中文编码这一常见问题展开，包括了对字符编码基础理论的简述以及常见几种编码标准的介绍。其中包括：ASCII、ISO8859-1、Unicode、GBK。下面先对这些字符编码集进行简单的介绍。</p>\n<h4 id=\"1-1-ASCII\"><a href=\"#1-1-ASCII\" class=\"headerlink\" title=\"1.1 ASCII\"></a>1.1 ASCII</h4><p>ASCII也就是美国信息交换标准码，采用单字节编码方案，但是编码只用了后七位字节，表示范围0-127共128个字符。ASCII码相对于其它编码也是最早出现的。从上世纪60年代提出开始，到1986年最终定型。</p>\n<blockquote>\n<p>为什么选择7位编码?ASCII在最初设计的时候需要至少能表示64个码元：包括26个字母+10个数字+图形标示+控制字符，如果用6bit编码，可扩展部分没有了，所以至少需要7bit。那么8bit呢？最终也被标准委员会否定，原因很简单：满足编码需求的前提下，最小化传输开销。</p>\n</blockquote>\n<h4 id=\"1-2-ISO8859-1\"><a href=\"#1-2-ISO8859-1\" class=\"headerlink\" title=\"1.2 ISO8859-1\"></a>1.2 ISO8859-1</h4><p>ISO-8859-1也被称为Latin1，使用单字节8bit编码，可以表示256个西欧字符。其隶属于ISO8859标准的一部分，还有ISO8859-2、ISO8859-3等等。每一种编码都对应一个地区的字符集。比如：ISO8859-1表示西欧字符，ISO-8859-16表示中欧字符集，等等。</p>\n<h4 id=\"1-3-Unicode\"><a href=\"#1-3-Unicode\" class=\"headerlink\" title=\"1.3 Unicode\"></a>1.3 Unicode</h4><p>不管是ASCII还是ISO8859-1，其编码范围都是有局限的。而Unicode标准的目标就是消除传统编码的<strong>局限性</strong>。</p>\n<blockquote>\n<p>这里的局限性一方面指编码范围的局限性：比如ASCII只能表示128个字符。还有编码兼容性方面的局限性：比如ISO8859代表的一系列编码字符集虽然可以表示大部分国家地区的字符，但是彼此的兼容性做的不好。Unicode的目标就如同其名称的含义一样：“实现字符编码统一”</p>\n</blockquote>\n<blockquote>\n<p>Unicode标准的实现方案有如下三种：<strong>UTF-8</strong>、<strong>UTF-16和</strong>UTF-32**.</p>\n</blockquote>\n<p><strong>UTF-8</strong>是变长编码，使用1到4个字节。UTF-8在设计时考虑到向前兼容，所以其前128个字符和ASCII完全一样，也就是说，所有ASCII同时也都符合UTF-8编码格式。其格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0xxxxxxx</span><br><span class=\"line\">110xxxxx \t10xxxxxx</span><br><span class=\"line\">1110xxxx \t10xxxxxx \t10xxxxxx</span><br><span class=\"line\">11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx</span><br></pre></td></tr></table></figure>\n<p>字节首部为0的话，也就是前面说的ASCII了。此外，字节<strong>首部连续1的个数</strong>就代表了该字符编码后所占的字节数。目前全世界的网页编码绝大多数使用的就是UTF-8，占比接近90%。</p>\n<p><strong>UTF-16</strong>也是变长编码，但其最初是<strong>固定16-bit宽度的定长编码</strong>，主要因为Unicode涵盖的字符太多了。两字节更本不够用！</p>\n<p><strong>UTF-32</strong>是32-bit定长编码，优点：定长编码在处理效率上相对于变长编码要高，此外，可通过<strong>索引</strong>访问任意字符是其另一大优势；缺点也很明显：32bit太浪费了！存储效率太低！</p>\n<blockquote>\n<p>big-endian和little-endian？在多字节编码标准中可能会遇到这样的问题：假如一个字符用两个字节表示，那么当读取这个字符的时候，哪个字节表示高有效位？哪个表示低有效位呢？这就涉及到字节的存储顺序问题。在Unicode中UTF-16和UTF-32都会面临这个问题。通常用BOM（Byte Order Mark）来进行区分。BOM用一个”U+FEFF”来表示，这个值在<br>Unicode中是没有对应字符的。不仅可以用其来指定字节顺序，还可以表示字节流的编码方式。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;len1:&quot; + &quot;a&quot;.getBytes(&quot;UTF16&quot;).length);</span><br><span class=\"line\">System.out.println(&quot;len2:&quot; + &quot;aa&quot;.getBytes(&quot;UTF16&quot;).length);</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>len1:4</p>\n</blockquote>\n<blockquote>\n<p>len2:6</p>\n</blockquote>\n<p>为什么是4和6，<strong>不应该是2和4吗！？</strong>。输出编码后的字节序列可以发现，起始的两个字节都是：”fe ff”。</p>\n<blockquote>\n<p>Java的char类型用什么编码格式？Java语言规范规定了Java的char类型使用的是UTF-16。这就是为什么Java的char占用两个字节的原因。此外，Java标准库实现的对char与String的序列化规定使用UTF-8。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16，当然，在设计java的时候UTF-16还是定长的）与外部存储的空间效率（采用变长的UTF-8编码）而做的取舍。</p>\n</blockquote>\n<h4 id=\"1-4-GBK\"><a href=\"#1-4-GBK\" class=\"headerlink\" title=\"1.4 GBK\"></a>1.4 GBK</h4><p>GBK是用于对简体中文进行编码。每个字符用两字节表示，同时兼容GB2312标准。</p>\n<h2 id=\"2-可能发生的中文乱码\"><a href=\"#2-可能发生的中文乱码\" class=\"headerlink\" title=\"2. 可能发生的中文乱码\"></a>2. 可能发生的中文乱码</h2><p>这一小节介绍软件开发中常见的中文编码乱码问题，在下面示例中：对于给定的一个包含中文的字符串”你好Java”，看一下都会出现哪些乱码问题。</p>\n<h4 id=\"2-1-中文变问号，如：\"><a href=\"#2-1-中文变问号，如：\" class=\"headerlink\" title=\"2.1 中文变问号，如：?????\"></a>2.1 中文变问号，如：?????</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;你好Java&quot;  ------&gt;  &quot;??Java&quot;</span><br></pre></td></tr></table></figure>\n<p>这种情况一般是由于<strong>中文字符经ISO8859-1编码造成的。</strong>下面是编码的具体过程：</p>\n<p>原字符串：”你好Java”</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4f60</td>\n<td>597d</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>经ISO8859-1编码后：</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3f</td>\n<td>3f</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>编码后字符串：”??Java”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = &quot;你好Java&quot;;</span><br><span class=\"line\">System.out.println(byteToHexString(str.getBytes(CHARSET_ISO88591)));</span><br><span class=\"line\">System.out.println(new String(str.getBytes(CHARSET_ISO88591)));</span><br><span class=\"line\">输出：</span><br><span class=\"line\">3f 3f 4a 61 76 61</span><br><span class=\"line\">??Java</span><br></pre></td></tr></table></figure>\n<p>我们知道ISO8859-1是单字节编码，而对于汉字已经超出ISO8859-1的编码范围，会被转化为”3f”，我们查表可知，”3f”对应的字符正是”?”。</p>\n<blockquote>\n<p>中文变问号的乱码情况是非常常见的，大部分开源软件的默认编码设置成了ISO8859-1，这点需要格外注意。</p>\n</blockquote>\n<h4 id=\"2-2-中文变奇怪字符，如：a½-a¥½-或者-AaºA\"><a href=\"#2-2-中文变奇怪字符，如：a½-a¥½-或者-AaºA\" class=\"headerlink\" title=\"2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\"></a>2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;你好Java&quot;  ------&gt;  &quot;ä½ å¥½Java&quot;</span><br></pre></td></tr></table></figure>\n<p>原字符串：”你好Java”</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4f60</td>\n<td>597d</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>经UTF-8编码后，一个中文用三个字节表示：</p>\n<p>你 | 好 | J| a| v| a<br>—|—|—|—|—|—|—|—<br>e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61</p>\n<blockquote>\n<p>乱码原因：UTF8编码或GBK编码，再由ISO8859-1解码。对照ISO8859-1编码表后发现：e4 bd a0分别对应三个字符：”ä½ “,e5 a5 bd分别对应三个字符”å¥½”,</p>\n</blockquote>\n<h4 id=\"2-3-中文变“复杂中文”如：浣犲ソ\"><a href=\"#2-3-中文变“复杂中文”如：浣犲ソ\" class=\"headerlink\" title=\"2.3 中文变“复杂中文”如：浣犲ソ\"></a>2.3 中文变“复杂中文”如：浣犲ソ</h4><p>下面依然是”你好Java”经过UTF-8编码后对应的字节序列：</p>\n<p>你 | 好 | J| a| v| a<br>—|—|—|—|—|—|—|—<br>e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61</p>\n<p>在GBK表中查找：e4 bd对应字符：”浣”,a0 e5对应字符：”犲”,a5 bd对应字符：”ソ”</p>\n<blockquote>\n<p>同理，如果GBK编码的中文用UTF-8来解码的话，同样会出现乱码问题。</p>\n</blockquote>\n<h4 id=\"2-4-中文变成一堆黑色菱形-问号，如：�����\"><a href=\"#2-4-中文变成一堆黑色菱形-问号，如：�����\" class=\"headerlink\" title=\"2.4 中文变成一堆黑色菱形+问号，如：�����\"></a>2.4 中文变成一堆黑色菱形+问号，如：�����</h4><p>首先问号+黑色菱形的字符是Unicode中的”REPLACEMENT CHARACTER”,该字符的主要作用是用来表示不识别的字符。<br>所以产生乱码的原因可能有很多，下面通过原字符串：”你好Java”，重现一种乱码方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原字符串：String str = &quot;你好Java&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">你 | 好 | J| a| v| a</span><br><span class=\"line\">---|---|---|---|---|---</span><br><span class=\"line\">4f60 | 597d | 4a| 61| 76| 61</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-16编码后</span><br><span class=\"line\"></span><br><span class=\"line\">fe ff 4f 60 59 7d 0 4a 0 61 0 76 0 61</span><br></pre></td></tr></table></figure>\n<p>其中”fe ff”就是字节流起始的BOM标识符。”fe ff”在Unicode标准中属于”noncharacters”,只用于内部使用。所以，<br>在输出该字节序列的时候，没有该码元对应的字符，对于不识别字符，就会用��替代。</p>\n<h2 id=\"3-Web开发中涉及到的中文编解码\"><a href=\"#3-Web开发中涉及到的中文编解码\" class=\"headerlink\" title=\"3. Web开发中涉及到的中文编解码\"></a>3. Web开发中涉及到的中文编解码</h2><p>Web中的数据大多通过http协议进行传输，所涉及到的一些编解码问题都围绕着http协议。下面以Tomcat作为Web服务器，<br>探讨下一个完整的请求响应流程中哪些地方会涉及到中文的编解码。</p>\n<h4 id=\"3-1-url编解码\"><a href=\"#3-1-url编解码\" class=\"headerlink\" title=\"3.1 url编解码\"></a>3.1 url编解码</h4><p>web环境中的中文乱码问题，实验如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsp中的form表单：</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;manager/codec/你好&quot;&gt;</span><br><span class=\"line\">\t\t&lt;table&gt;</span><br><span class=\"line\">\t\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t\t&lt;td&gt;用户名： &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;td&gt;地址 &lt;input type=&quot;text&quot; name=&quot;address&quot; id=&quot;address&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;th&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;保存&quot; /&gt;&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t&lt;/table&gt;</span><br><span class=\"line\">\t&lt;/form&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">后端使用SpringMVC的Controller：</span><br><span class=\"line\"></span><br><span class=\"line\">@Controller()</span><br><span class=\"line\">@RequestMapping(&quot;/manager&quot;)</span><br><span class=\"line\">public class ManagerController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/test/&#123;param&#125;&quot;)</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    public String test(@PathVariable String param, HttpServletRequest request)&#123;</span><br><span class=\"line\">        String name = request.getParameter(&quot;name&quot;);</span><br><span class=\"line\">        System.out.println(&quot;name:&quot; + name + &quot;,param:&quot; + param);</span><br><span class=\"line\">        return &quot;test&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表单中填入内容：<br>用户名：你好 Java<br>地址：123<br>提交请求，firebug中的显示的url如下：</p>\n<blockquote>\n<p><a href=\"http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD</a></p>\n</blockquote>\n<p>查阅编码可以，firefox对url中出现的中文使用了UTF-8的编码方式。之所以url中出现%，这是因为根据URL编码规范，浏览器会将非ASCII字符编成16进制后，每个字节前需要加%。</p>\n<p>后端控制台输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name:ä½ å¥½ Java,param:ä½ å¥½</span><br></pre></td></tr></table></figure>\n\n<p>可见无论是url中的中文信息或是post表单中的中文都出现了乱码现象，从前一节中关于乱码情况的分析来看，这里应该是<strong>中文字符经过浏览器UTF-8编码后，Server端用ISO8859-1进行解码所致。</strong>下面逐个分析url和post表单如何进行编解码的。</p>\n<p>在tomcat中url的byte -&gt; char的转换是在org.apache.catalina.connector.CoyoteAdapter类的convertURI(MessageBytes uri, Request request)方法中执行的，源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    protected void convertURI(MessageBytes uri, Request request)throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ByteChunk bc = uri.getByteChunk();</span><br><span class=\"line\">        int length = bc.getLength();</span><br><span class=\"line\">        CharChunk cc = uri.getCharChunk();</span><br><span class=\"line\">        cc.allocate(length, -1);</span><br><span class=\"line\">    </span><br><span class=\"line\">//这里获取的connector的URIEncoding属性，即server.xml文件中connector元素的URIEncoding属性</span><br><span class=\"line\">        String enc = connector.getURIEncoding();</span><br><span class=\"line\">        if (enc != null) &#123;</span><br><span class=\"line\">            B2CConverter conv = request.getURIConverter();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (conv == null) &#123;</span><br><span class=\"line\">                    conv = new B2CConverter(enc, true);</span><br><span class=\"line\">                    request.setURIConverter(conv);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    conv.recycle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                log.error(&quot;Invalid URI encoding; using HTTP default&quot;);</span><br><span class=\"line\">                connector.setURIEncoding(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (conv != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    conv.convert(bc, cc, true);</span><br><span class=\"line\">                    uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength());</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125; catch (IOException ioe) &#123;</span><br><span class=\"line\">                    request.getResponse().sendError(</span><br><span class=\"line\">                            HttpServletResponse.SC_BAD_REQUEST);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有配置URIEncoding，则在ByteChunk中默认使用ISO8859-1。</span><br><span class=\"line\">        byte[] bbuf = bc.getBuffer();</span><br><span class=\"line\">        char[] cbuf = cc.getBuffer();</span><br><span class=\"line\">        int start = bc.getStart();</span><br><span class=\"line\">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">            cbuf[i] = (char) (bbuf[i + start] &amp; 0xff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        uri.setChars(cbuf, 0, length);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在org.apache.tomcat.util.buf.ByteChunk中可以看到默认编码的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class ByteChunk implements Cloneable, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于请求url中的中文，我们按UTF-8进行编码，在服务端却按ISO8859-1进行解码，所以出现乱码现象。我们可以再Tomcat的server.xml中指定url的编解码格式，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector  URIEncoding=&quot;UTF-8&quot; 。。。&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此时重复上面实验，后端控制台输出：name:ä½ å¥½ Java,param:你好</p>\n</blockquote>\n<p>虽然url中的参数可以正常显示了，但是form表单中的参数name依然乱码，下面进一步分析。</p>\n<h3 id=\"3-2-form表单元素的编解码\"><a href=\"#3-2-form表单元素的编解码\" class=\"headerlink\" title=\"3.2 form表单元素的编解码\"></a>3.2 form表单元素的编解码</h3><p>name参数的编码依然是乱码的，为啥？首先<strong>定位form表单中参数是在哪里进行解码的。</strong>Form表单中的字符解码时机是发生在第一次调用request.getParameter时，可以通过request.setCharacterEncoding设置。<strong>需要注意的是setCharacterEncoding必须在getParameter之前调用！否则，setCharacterEncoding不会起作用。</strong></p>\n<p>Tomcat中HttpServletRequest接口的实现类是<strong>org.apache.catalina.connector.Request</strong>。下面是Request类中getParameter源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    @Override</span><br><span class=\"line\">    public String getParameter(String name) &#123;</span><br><span class=\"line\">        //判断参数是否被解析过</span><br><span class=\"line\">        if (!parametersParsed) &#123;</span><br><span class=\"line\">            parseParameters();//第一次参数解析</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return coyoteRequest.getParameters().getParameter(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//下面是parseParameters部分源码</span><br><span class=\"line\"></span><br><span class=\"line\">   protected void parseParameters() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //设为true，表示参数已解析过</span><br><span class=\"line\">        parametersParsed = true;</span><br><span class=\"line\">        //Parameters对象封装了form表单参数</span><br><span class=\"line\">        Parameters parameters = coyoteRequest.getParameters();</span><br><span class=\"line\">        </span><br><span class=\"line\">        boolean success = false;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // Set this every time in case limit has been changed via JMX</span><br><span class=\"line\">            parameters.setLimit(getConnector().getMaxParameterCount());</span><br><span class=\"line\">        </span><br><span class=\"line\">            //获取字符编码格式</span><br><span class=\"line\">            String enc = getCharacterEncoding();</span><br><span class=\"line\"></span><br><span class=\"line\">            boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();</span><br><span class=\"line\">            if (enc != null) &#123;</span><br><span class=\"line\">            //getCharacterEncoding不为null，则对应设置编码方式</span><br><span class=\"line\">                parameters.setEncoding(enc);</span><br><span class=\"line\">                if (useBodyEncodingForURI) &#123;</span><br><span class=\"line\">                    parameters.setQueryStringEncoding(enc);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                //如果enc为null，则编码方式设置为DEFAULT_CHARACTER_ENCODING，也就是ISO8859-1</span><br><span class=\"line\">                parameters.setEncoding</span><br><span class=\"line\">                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class=\"line\">                if (useBodyEncodingForURI) &#123;</span><br><span class=\"line\">                    parameters.setQueryStringEncoding</span><br><span class=\"line\">                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            parameters.handleQueryParameters();</span><br><span class=\"line\">            </span><br><span class=\"line\">            。。。</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从以上源码中可以看出为什么需要在第一次调用getParameter之前设置CharacterEncoding。因为第一次执行parseParameters时，会把parametersParsed变量设为true。所以parseParameters只会在第一次getParameter时调用。有时会出现这么一种怪像：通过request.getCharacterEncoding()得到的是我们认为正确的编码字符集，但是request.getParameter得到的依然是乱码。此时就需要考虑下我们调用setCharacterEncoding之前是否已经调用过getParameter方法了。</p>\n<blockquote>\n<p>经过上面的分析后，对于form表单参数乱码问题就很好解决了，在第一次调用request.getParameter方法前，通过request.setCharacterEncoding(“Expected_Encoding”);设置即可。这一步可以用Servlet标准中的Filter实现，不过，常用的MVC框架中已经有现成的Filter实现了，比如SpringMVC中的org.springframework.web.filter.CharacterEncodingFilter,如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void doFilterInternal(</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class=\"line\">\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123;</span><br><span class=\"line\">\t\trequest.setCharacterEncoding(this.encoding);//设置指定的编码</span><br><span class=\"line\">\t\tif (this.forceEncoding) &#123;</span><br><span class=\"line\">\t\t\tresponse.setCharacterEncoding(this.encoding);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfilterChain.doFilter(request, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-JSP中涉及的编码\"><a href=\"#3-3-JSP中涉及的编码\" class=\"headerlink\" title=\"3.3 JSP中涉及的编码\"></a>3.3 JSP中涉及的编码</h3><p>jsp中可以通过page指令指定一些编码参数，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class=\"line\">\tpageEncoding=&quot;UTF-8&quot;%&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"pageEncoding-”UTF-8”在什么时候起作用？\"><a href=\"#pageEncoding-”UTF-8”在什么时候起作用？\" class=\"headerlink\" title=\"pageEncoding=”UTF-8”在什么时候起作用？\"></a>pageEncoding=”UTF-8”在什么时候起作用？</h6><p>在Servlet标准中，jsp最终也会被编译成一个servlet。<strong>index.jsp-&gt;index_jsp.java</strong>.pageEncoding=”UTF-8”就是在这个解析过程中起作用的。</p>\n<h6 id=\"contentType-”text-html-charset-UTF-8”的作用？\"><a href=\"#contentType-”text-html-charset-UTF-8”的作用？\" class=\"headerlink\" title=\"contentType=”text/html; charset=UTF-8”的作用？\"></a>contentType=”text/html; charset=UTF-8”的作用？</h6><p>contentType是响应头中特定信息，主要的作用是告诉浏览器response中存放的主体对象类型和编码，这样浏览器就可以对指定类型进行正确解码，保证了数据在server和client端的一致性。当进行Servlet编程的时候，可以手动进行设置，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-文件的上传和下载中涉及到的中文乱码\"><a href=\"#3-4-文件的上传和下载中涉及到的中文乱码\" class=\"headerlink\" title=\"3.4 文件的上传和下载中涉及到的中文乱码\"></a>3.4 文件的上传和下载中涉及到的中文乱码</h3><p>Web中的文件操作主要是上传和下载，这个过程也是依托于Http协议作为数据载体。所以，最终是否乱码重点在于是否正确的设置http的request、response的header中的相关字段。如ContentType、Content-Disposition的设定等。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class=\"line\">response.setContentType(&quot;application/x-msdownload&quot;);</span><br><span class=\"line\">response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是<strong>Content-Disposition</strong>的filename属性值，如果fileName含有中文，那么要格外注意fileName字符串的编码格式。在<a href=\"https://tools.ietf.org/html/rfc5987\">rfc5987</a>对于HTTP的Header中参数的编码做出了明确的规定：</p>\n<blockquote>\n<p>By default, message header field parameters in Hypertext Transfer  Protocol (HTTP) messages cannot carry characters outside the ISO-8859-1 character set.</p>\n</blockquote>\n<p>也就是说默认情况下，Http的Header中的参数只能用ISO-8859-1字符集中的字符，那么是否意味着Content-Disposition中的fileName字符串也要转成ISO-8859-1了呢？答案是：NO！原因如下：Content-Disposition其实不属于Http/1.1标准。这在<a href=\"https://tools.ietf.org/html/rfc2616#section-15.5\">RFC2616</a>中有明确的说明。只因为其使用广泛，HTTP才对其支持。在<a href=\"https://tools.ietf.org/html/rfc6266#section-4.3\">rfc6266</a>中也详细介绍了Content-Disposition的filename参数含义和用法。下面是对于下载包含中文名称的文件时的解决方案。</p>\n<h6 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h6><p>最简单就是直接用ISO8859-1对文件名进行编码，大多数浏览器都支持。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exportFileName.getBytes(&quot;UTF-8&quot;),&quot;ISO8859-1&quot;);//这里的UTF-8也可能是别的编码，主要依据系统默认的编码来设定。</span><br></pre></td></tr></table></figure>\n<p>或通过其它编码，如UTF-8。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.addHeader(&quot;Content-Disposition&quot;,</span><br><span class=\"line\">                &quot;attachment; filename*=UTF-8&#x27;&#x27;&quot; + URLEncoder.encode(exportFileName, &quot;UTF8&quot;));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><p>编解码问题是多语言交互系统中必然要面对的问题，尤其对于中文环境中的开发者来说，在入门阶段或多或少都会遇到此类问题。乱码问题本质就是通信双方使用的标准不一致。所以，解决乱码问题的方法其实也很简单，统一下编解码标准即可。此外，深入理解各种编码标准的原理和关系也非常重要，在以后遇到类似问题的时候能够更加准确的判断出造成乱码的原因。</p>\n","site":{"data":{}},"excerpt":"","more":"<h6 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h6><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 字符编码理论简述</span><br><span class=\"line\">    1.1 ASCII</span><br><span class=\"line\">    1.2 ISO8859-1</span><br><span class=\"line\">    1.3 Unicode</span><br><span class=\"line\">    1.4 GBK</span><br><span class=\"line\">    </span><br><span class=\"line\">2. 可能发生的中文乱码</span><br><span class=\"line\">    2.1 中文变问号，如：???</span><br><span class=\"line\">    2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ</span><br><span class=\"line\">    2.3 中文变“复杂中文”，如：浣犲ソ</span><br><span class=\"line\">    2.4 中文变成一堆黑色菱形+问号，如：�����</span><br><span class=\"line\"></span><br><span class=\"line\">3. Web开发中涉及到的中文编解码</span><br><span class=\"line\">    3.1 URL中出现的中文</span><br><span class=\"line\">    3.2 Form表单中出现的中文</span><br><span class=\"line\">    3.3 JSP中涉及的编码</span><br><span class=\"line\">    3.4 文件的上传和下载中涉及到的中文乱码</span><br><span class=\"line\">4. 总结</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-字符编码理论简述\"><a href=\"#1-字符编码理论简述\" class=\"headerlink\" title=\"1. 字符编码理论简述\"></a>1. 字符编码理论简述</h2><p>本文主要是围绕Web开发中涉及到的中文编码这一常见问题展开，包括了对字符编码基础理论的简述以及常见几种编码标准的介绍。其中包括：ASCII、ISO8859-1、Unicode、GBK。下面先对这些字符编码集进行简单的介绍。</p>\n<h4 id=\"1-1-ASCII\"><a href=\"#1-1-ASCII\" class=\"headerlink\" title=\"1.1 ASCII\"></a>1.1 ASCII</h4><p>ASCII也就是美国信息交换标准码，采用单字节编码方案，但是编码只用了后七位字节，表示范围0-127共128个字符。ASCII码相对于其它编码也是最早出现的。从上世纪60年代提出开始，到1986年最终定型。</p>\n<blockquote>\n<p>为什么选择7位编码?ASCII在最初设计的时候需要至少能表示64个码元：包括26个字母+10个数字+图形标示+控制字符，如果用6bit编码，可扩展部分没有了，所以至少需要7bit。那么8bit呢？最终也被标准委员会否定，原因很简单：满足编码需求的前提下，最小化传输开销。</p>\n</blockquote>\n<h4 id=\"1-2-ISO8859-1\"><a href=\"#1-2-ISO8859-1\" class=\"headerlink\" title=\"1.2 ISO8859-1\"></a>1.2 ISO8859-1</h4><p>ISO-8859-1也被称为Latin1，使用单字节8bit编码，可以表示256个西欧字符。其隶属于ISO8859标准的一部分，还有ISO8859-2、ISO8859-3等等。每一种编码都对应一个地区的字符集。比如：ISO8859-1表示西欧字符，ISO-8859-16表示中欧字符集，等等。</p>\n<h4 id=\"1-3-Unicode\"><a href=\"#1-3-Unicode\" class=\"headerlink\" title=\"1.3 Unicode\"></a>1.3 Unicode</h4><p>不管是ASCII还是ISO8859-1，其编码范围都是有局限的。而Unicode标准的目标就是消除传统编码的<strong>局限性</strong>。</p>\n<blockquote>\n<p>这里的局限性一方面指编码范围的局限性：比如ASCII只能表示128个字符。还有编码兼容性方面的局限性：比如ISO8859代表的一系列编码字符集虽然可以表示大部分国家地区的字符，但是彼此的兼容性做的不好。Unicode的目标就如同其名称的含义一样：“实现字符编码统一”</p>\n</blockquote>\n<blockquote>\n<p>Unicode标准的实现方案有如下三种：<strong>UTF-8</strong>、<strong>UTF-16和</strong>UTF-32**.</p>\n</blockquote>\n<p><strong>UTF-8</strong>是变长编码，使用1到4个字节。UTF-8在设计时考虑到向前兼容，所以其前128个字符和ASCII完全一样，也就是说，所有ASCII同时也都符合UTF-8编码格式。其格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0xxxxxxx</span><br><span class=\"line\">110xxxxx \t10xxxxxx</span><br><span class=\"line\">1110xxxx \t10xxxxxx \t10xxxxxx</span><br><span class=\"line\">11110xxx \t10xxxxxx \t10xxxxxx \t10xxxxxx</span><br></pre></td></tr></table></figure>\n<p>字节首部为0的话，也就是前面说的ASCII了。此外，字节<strong>首部连续1的个数</strong>就代表了该字符编码后所占的字节数。目前全世界的网页编码绝大多数使用的就是UTF-8，占比接近90%。</p>\n<p><strong>UTF-16</strong>也是变长编码，但其最初是<strong>固定16-bit宽度的定长编码</strong>，主要因为Unicode涵盖的字符太多了。两字节更本不够用！</p>\n<p><strong>UTF-32</strong>是32-bit定长编码，优点：定长编码在处理效率上相对于变长编码要高，此外，可通过<strong>索引</strong>访问任意字符是其另一大优势；缺点也很明显：32bit太浪费了！存储效率太低！</p>\n<blockquote>\n<p>big-endian和little-endian？在多字节编码标准中可能会遇到这样的问题：假如一个字符用两个字节表示，那么当读取这个字符的时候，哪个字节表示高有效位？哪个表示低有效位呢？这就涉及到字节的存储顺序问题。在Unicode中UTF-16和UTF-32都会面临这个问题。通常用BOM（Byte Order Mark）来进行区分。BOM用一个”U+FEFF”来表示，这个值在<br>Unicode中是没有对应字符的。不仅可以用其来指定字节顺序，还可以表示字节流的编码方式。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(&quot;len1:&quot; + &quot;a&quot;.getBytes(&quot;UTF16&quot;).length);</span><br><span class=\"line\">System.out.println(&quot;len2:&quot; + &quot;aa&quot;.getBytes(&quot;UTF16&quot;).length);</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>len1:4</p>\n</blockquote>\n<blockquote>\n<p>len2:6</p>\n</blockquote>\n<p>为什么是4和6，<strong>不应该是2和4吗！？</strong>。输出编码后的字节序列可以发现，起始的两个字节都是：”fe ff”。</p>\n<blockquote>\n<p>Java的char类型用什么编码格式？Java语言规范规定了Java的char类型使用的是UTF-16。这就是为什么Java的char占用两个字节的原因。此外，Java标准库实现的对char与String的序列化规定使用UTF-8。Java的Class文件中的字符串常量与符号名字也都规定用UTF-8编码。这大概是当时设计者为了平衡运行时的时间效率（采用定长编码的UTF-16，当然，在设计java的时候UTF-16还是定长的）与外部存储的空间效率（采用变长的UTF-8编码）而做的取舍。</p>\n</blockquote>\n<h4 id=\"1-4-GBK\"><a href=\"#1-4-GBK\" class=\"headerlink\" title=\"1.4 GBK\"></a>1.4 GBK</h4><p>GBK是用于对简体中文进行编码。每个字符用两字节表示，同时兼容GB2312标准。</p>\n<h2 id=\"2-可能发生的中文乱码\"><a href=\"#2-可能发生的中文乱码\" class=\"headerlink\" title=\"2. 可能发生的中文乱码\"></a>2. 可能发生的中文乱码</h2><p>这一小节介绍软件开发中常见的中文编码乱码问题，在下面示例中：对于给定的一个包含中文的字符串”你好Java”，看一下都会出现哪些乱码问题。</p>\n<h4 id=\"2-1-中文变问号，如：\"><a href=\"#2-1-中文变问号，如：\" class=\"headerlink\" title=\"2.1 中文变问号，如：?????\"></a>2.1 中文变问号，如：?????</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;你好Java&quot;  ------&gt;  &quot;??Java&quot;</span><br></pre></td></tr></table></figure>\n<p>这种情况一般是由于<strong>中文字符经ISO8859-1编码造成的。</strong>下面是编码的具体过程：</p>\n<p>原字符串：”你好Java”</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4f60</td>\n<td>597d</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>经ISO8859-1编码后：</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3f</td>\n<td>3f</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>编码后字符串：”??Java”</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str = &quot;你好Java&quot;;</span><br><span class=\"line\">System.out.println(byteToHexString(str.getBytes(CHARSET_ISO88591)));</span><br><span class=\"line\">System.out.println(new String(str.getBytes(CHARSET_ISO88591)));</span><br><span class=\"line\">输出：</span><br><span class=\"line\">3f 3f 4a 61 76 61</span><br><span class=\"line\">??Java</span><br></pre></td></tr></table></figure>\n<p>我们知道ISO8859-1是单字节编码，而对于汉字已经超出ISO8859-1的编码范围，会被转化为”3f”，我们查表可知，”3f”对应的字符正是”?”。</p>\n<blockquote>\n<p>中文变问号的乱码情况是非常常见的，大部分开源软件的默认编码设置成了ISO8859-1，这点需要格外注意。</p>\n</blockquote>\n<h4 id=\"2-2-中文变奇怪字符，如：a½-a¥½-或者-AaºA\"><a href=\"#2-2-中文变奇怪字符，如：a½-a¥½-或者-AaºA\" class=\"headerlink\" title=\"2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ\"></a>2.2 中文变奇怪字符，如：ä½ å¥½ 或者 ÄãºÃ</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;你好Java&quot;  ------&gt;  &quot;ä½ å¥½Java&quot;</span><br></pre></td></tr></table></figure>\n<p>原字符串：”你好Java”</p>\n<table>\n<thead>\n<tr>\n<th>你</th>\n<th>好</th>\n<th>J</th>\n<th>a</th>\n<th>v</th>\n<th>a</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>4f60</td>\n<td>597d</td>\n<td>4a</td>\n<td>61</td>\n<td>76</td>\n<td>61</td>\n</tr>\n</tbody></table>\n<p>经UTF-8编码后，一个中文用三个字节表示：</p>\n<p>你 | 好 | J| a| v| a<br>—|—|—|—|—|—|—|—<br>e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61</p>\n<blockquote>\n<p>乱码原因：UTF8编码或GBK编码，再由ISO8859-1解码。对照ISO8859-1编码表后发现：e4 bd a0分别对应三个字符：”ä½ “,e5 a5 bd分别对应三个字符”å¥½”,</p>\n</blockquote>\n<h4 id=\"2-3-中文变“复杂中文”如：浣犲ソ\"><a href=\"#2-3-中文变“复杂中文”如：浣犲ソ\" class=\"headerlink\" title=\"2.3 中文变“复杂中文”如：浣犲ソ\"></a>2.3 中文变“复杂中文”如：浣犲ソ</h4><p>下面依然是”你好Java”经过UTF-8编码后对应的字节序列：</p>\n<p>你 | 好 | J| a| v| a<br>—|—|—|—|—|—|—|—<br>e4 bd a0 | e5 a5 bd | 4a| 61| 76| 61</p>\n<p>在GBK表中查找：e4 bd对应字符：”浣”,a0 e5对应字符：”犲”,a5 bd对应字符：”ソ”</p>\n<blockquote>\n<p>同理，如果GBK编码的中文用UTF-8来解码的话，同样会出现乱码问题。</p>\n</blockquote>\n<h4 id=\"2-4-中文变成一堆黑色菱形-问号，如：�����\"><a href=\"#2-4-中文变成一堆黑色菱形-问号，如：�����\" class=\"headerlink\" title=\"2.4 中文变成一堆黑色菱形+问号，如：�����\"></a>2.4 中文变成一堆黑色菱形+问号，如：�����</h4><p>首先问号+黑色菱形的字符是Unicode中的”REPLACEMENT CHARACTER”,该字符的主要作用是用来表示不识别的字符。<br>所以产生乱码的原因可能有很多，下面通过原字符串：”你好Java”，重现一种乱码方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原字符串：String str = &quot;你好Java&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">你 | 好 | J| a| v| a</span><br><span class=\"line\">---|---|---|---|---|---</span><br><span class=\"line\">4f60 | 597d | 4a| 61| 76| 61</span><br><span class=\"line\"></span><br><span class=\"line\">UTF-16编码后</span><br><span class=\"line\"></span><br><span class=\"line\">fe ff 4f 60 59 7d 0 4a 0 61 0 76 0 61</span><br></pre></td></tr></table></figure>\n<p>其中”fe ff”就是字节流起始的BOM标识符。”fe ff”在Unicode标准中属于”noncharacters”,只用于内部使用。所以，<br>在输出该字节序列的时候，没有该码元对应的字符，对于不识别字符，就会用��替代。</p>\n<h2 id=\"3-Web开发中涉及到的中文编解码\"><a href=\"#3-Web开发中涉及到的中文编解码\" class=\"headerlink\" title=\"3. Web开发中涉及到的中文编解码\"></a>3. Web开发中涉及到的中文编解码</h2><p>Web中的数据大多通过http协议进行传输，所涉及到的一些编解码问题都围绕着http协议。下面以Tomcat作为Web服务器，<br>探讨下一个完整的请求响应流程中哪些地方会涉及到中文的编解码。</p>\n<h4 id=\"3-1-url编解码\"><a href=\"#3-1-url编解码\" class=\"headerlink\" title=\"3.1 url编解码\"></a>3.1 url编解码</h4><p>web环境中的中文乱码问题，实验如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsp中的form表单：</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;form name=&quot;form&quot; method=&quot;post&quot; action=&quot;manager/codec/你好&quot;&gt;</span><br><span class=\"line\">\t\t&lt;table&gt;</span><br><span class=\"line\">\t\t\t&lt;tr&gt;</span><br><span class=\"line\">\t\t\t\t&lt;td&gt;用户名： &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;td&gt;地址 &lt;input type=&quot;text&quot; name=&quot;address&quot; id=&quot;address&quot; /&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/td&gt;</span><br><span class=\"line\">\t\t\t\t&lt;th&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;保存&quot; /&gt;&lt;/th&gt;</span><br><span class=\"line\">\t\t\t&lt;/tr&gt;</span><br><span class=\"line\">\t\t&lt;/table&gt;</span><br><span class=\"line\">\t&lt;/form&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">后端使用SpringMVC的Controller：</span><br><span class=\"line\"></span><br><span class=\"line\">@Controller()</span><br><span class=\"line\">@RequestMapping(&quot;/manager&quot;)</span><br><span class=\"line\">public class ManagerController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RequestMapping(&quot;/test/&#123;param&#125;&quot;)</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    public String test(@PathVariable String param, HttpServletRequest request)&#123;</span><br><span class=\"line\">        String name = request.getParameter(&quot;name&quot;);</span><br><span class=\"line\">        System.out.println(&quot;name:&quot; + name + &quot;,param:&quot; + param);</span><br><span class=\"line\">        return &quot;test&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>表单中填入内容：<br>用户名：你好 Java<br>地址：123<br>提交请求，firebug中的显示的url如下：</p>\n<blockquote>\n<p><a href=\"http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD\">http://localhost:8080/fdyuntu-ssm/manager/codec/%E4%BD%A0%E5%A5%BD</a></p>\n</blockquote>\n<p>查阅编码可以，firefox对url中出现的中文使用了UTF-8的编码方式。之所以url中出现%，这是因为根据URL编码规范，浏览器会将非ASCII字符编成16进制后，每个字节前需要加%。</p>\n<p>后端控制台输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name:ä½ å¥½ Java,param:ä½ å¥½</span><br></pre></td></tr></table></figure>\n\n<p>可见无论是url中的中文信息或是post表单中的中文都出现了乱码现象，从前一节中关于乱码情况的分析来看，这里应该是<strong>中文字符经过浏览器UTF-8编码后，Server端用ISO8859-1进行解码所致。</strong>下面逐个分析url和post表单如何进行编解码的。</p>\n<p>在tomcat中url的byte -&gt; char的转换是在org.apache.catalina.connector.CoyoteAdapter类的convertURI(MessageBytes uri, Request request)方法中执行的，源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    protected void convertURI(MessageBytes uri, Request request)throws Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ByteChunk bc = uri.getByteChunk();</span><br><span class=\"line\">        int length = bc.getLength();</span><br><span class=\"line\">        CharChunk cc = uri.getCharChunk();</span><br><span class=\"line\">        cc.allocate(length, -1);</span><br><span class=\"line\">    </span><br><span class=\"line\">//这里获取的connector的URIEncoding属性，即server.xml文件中connector元素的URIEncoding属性</span><br><span class=\"line\">        String enc = connector.getURIEncoding();</span><br><span class=\"line\">        if (enc != null) &#123;</span><br><span class=\"line\">            B2CConverter conv = request.getURIConverter();</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                if (conv == null) &#123;</span><br><span class=\"line\">                    conv = new B2CConverter(enc, true);</span><br><span class=\"line\">                    request.setURIConverter(conv);</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    conv.recycle();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                log.error(&quot;Invalid URI encoding; using HTTP default&quot;);</span><br><span class=\"line\">                connector.setURIEncoding(null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (conv != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    conv.convert(bc, cc, true);</span><br><span class=\"line\">                    uri.setChars(cc.getBuffer(), cc.getStart(), cc.getLength());</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125; catch (IOException ioe) &#123;</span><br><span class=\"line\">                    request.getResponse().sendError(</span><br><span class=\"line\">                            HttpServletResponse.SC_BAD_REQUEST);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果没有配置URIEncoding，则在ByteChunk中默认使用ISO8859-1。</span><br><span class=\"line\">        byte[] bbuf = bc.getBuffer();</span><br><span class=\"line\">        char[] cbuf = cc.getBuffer();</span><br><span class=\"line\">        int start = bc.getStart();</span><br><span class=\"line\">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">            cbuf[i] = (char) (bbuf[i + start] &amp; 0xff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        uri.setChars(cbuf, 0, length);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在org.apache.tomcat.util.buf.ByteChunk中可以看到默认编码的定义：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final class ByteChunk implements Cloneable, Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">    </span><br><span class=\"line\">    public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //。。。</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以对于请求url中的中文，我们按UTF-8进行编码，在服务端却按ISO8859-1进行解码，所以出现乱码现象。我们可以再Tomcat的server.xml中指定url的编解码格式，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector  URIEncoding=&quot;UTF-8&quot; 。。。&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此时重复上面实验，后端控制台输出：name:ä½ å¥½ Java,param:你好</p>\n</blockquote>\n<p>虽然url中的参数可以正常显示了，但是form表单中的参数name依然乱码，下面进一步分析。</p>\n<h3 id=\"3-2-form表单元素的编解码\"><a href=\"#3-2-form表单元素的编解码\" class=\"headerlink\" title=\"3.2 form表单元素的编解码\"></a>3.2 form表单元素的编解码</h3><p>name参数的编码依然是乱码的，为啥？首先<strong>定位form表单中参数是在哪里进行解码的。</strong>Form表单中的字符解码时机是发生在第一次调用request.getParameter时，可以通过request.setCharacterEncoding设置。<strong>需要注意的是setCharacterEncoding必须在getParameter之前调用！否则，setCharacterEncoding不会起作用。</strong></p>\n<p>Tomcat中HttpServletRequest接口的实现类是<strong>org.apache.catalina.connector.Request</strong>。下面是Request类中getParameter源码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    @Override</span><br><span class=\"line\">    public String getParameter(String name) &#123;</span><br><span class=\"line\">        //判断参数是否被解析过</span><br><span class=\"line\">        if (!parametersParsed) &#123;</span><br><span class=\"line\">            parseParameters();//第一次参数解析</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        return coyoteRequest.getParameters().getParameter(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//下面是parseParameters部分源码</span><br><span class=\"line\"></span><br><span class=\"line\">   protected void parseParameters() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //设为true，表示参数已解析过</span><br><span class=\"line\">        parametersParsed = true;</span><br><span class=\"line\">        //Parameters对象封装了form表单参数</span><br><span class=\"line\">        Parameters parameters = coyoteRequest.getParameters();</span><br><span class=\"line\">        </span><br><span class=\"line\">        boolean success = false;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // Set this every time in case limit has been changed via JMX</span><br><span class=\"line\">            parameters.setLimit(getConnector().getMaxParameterCount());</span><br><span class=\"line\">        </span><br><span class=\"line\">            //获取字符编码格式</span><br><span class=\"line\">            String enc = getCharacterEncoding();</span><br><span class=\"line\"></span><br><span class=\"line\">            boolean useBodyEncodingForURI = connector.getUseBodyEncodingForURI();</span><br><span class=\"line\">            if (enc != null) &#123;</span><br><span class=\"line\">            //getCharacterEncoding不为null，则对应设置编码方式</span><br><span class=\"line\">                parameters.setEncoding(enc);</span><br><span class=\"line\">                if (useBodyEncodingForURI) &#123;</span><br><span class=\"line\">                    parameters.setQueryStringEncoding(enc);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                //如果enc为null，则编码方式设置为DEFAULT_CHARACTER_ENCODING，也就是ISO8859-1</span><br><span class=\"line\">                parameters.setEncoding</span><br><span class=\"line\">                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class=\"line\">                if (useBodyEncodingForURI) &#123;</span><br><span class=\"line\">                    parameters.setQueryStringEncoding</span><br><span class=\"line\">                    (org.apache.coyote.Constants.DEFAULT_CHARACTER_ENCODING);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            parameters.handleQueryParameters();</span><br><span class=\"line\">            </span><br><span class=\"line\">            。。。</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>从以上源码中可以看出为什么需要在第一次调用getParameter之前设置CharacterEncoding。因为第一次执行parseParameters时，会把parametersParsed变量设为true。所以parseParameters只会在第一次getParameter时调用。有时会出现这么一种怪像：通过request.getCharacterEncoding()得到的是我们认为正确的编码字符集，但是request.getParameter得到的依然是乱码。此时就需要考虑下我们调用setCharacterEncoding之前是否已经调用过getParameter方法了。</p>\n<blockquote>\n<p>经过上面的分析后，对于form表单参数乱码问题就很好解决了，在第一次调用request.getParameter方法前，通过request.setCharacterEncoding(“Expected_Encoding”);设置即可。这一步可以用Servlet标准中的Filter实现，不过，常用的MVC框架中已经有现成的Filter实现了，比如SpringMVC中的org.springframework.web.filter.CharacterEncodingFilter,如下：</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">protected void doFilterInternal(</span><br><span class=\"line\">\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span><br><span class=\"line\">\t\tthrows ServletException, IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123;</span><br><span class=\"line\">\t\trequest.setCharacterEncoding(this.encoding);//设置指定的编码</span><br><span class=\"line\">\t\tif (this.forceEncoding) &#123;</span><br><span class=\"line\">\t\t\tresponse.setCharacterEncoding(this.encoding);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfilterChain.doFilter(request, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-3-JSP中涉及的编码\"><a href=\"#3-3-JSP中涉及的编码\" class=\"headerlink\" title=\"3.3 JSP中涉及的编码\"></a>3.3 JSP中涉及的编码</h3><p>jsp中可以通过page指令指定一些编码参数，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class=\"line\">\tpageEncoding=&quot;UTF-8&quot;%&gt;</span><br></pre></td></tr></table></figure>\n<h6 id=\"pageEncoding-”UTF-8”在什么时候起作用？\"><a href=\"#pageEncoding-”UTF-8”在什么时候起作用？\" class=\"headerlink\" title=\"pageEncoding=”UTF-8”在什么时候起作用？\"></a>pageEncoding=”UTF-8”在什么时候起作用？</h6><p>在Servlet标准中，jsp最终也会被编译成一个servlet。<strong>index.jsp-&gt;index_jsp.java</strong>.pageEncoding=”UTF-8”就是在这个解析过程中起作用的。</p>\n<h6 id=\"contentType-”text-html-charset-UTF-8”的作用？\"><a href=\"#contentType-”text-html-charset-UTF-8”的作用？\" class=\"headerlink\" title=\"contentType=”text/html; charset=UTF-8”的作用？\"></a>contentType=”text/html; charset=UTF-8”的作用？</h6><p>contentType是响应头中特定信息，主要的作用是告诉浏览器response中存放的主体对象类型和编码，这样浏览器就可以对指定类型进行正确解码，保证了数据在server和client端的一致性。当进行Servlet编程的时候，可以手动进行设置，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setContentType(&quot;text/html; charset=UTF-8&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-文件的上传和下载中涉及到的中文乱码\"><a href=\"#3-4-文件的上传和下载中涉及到的中文乱码\" class=\"headerlink\" title=\"3.4 文件的上传和下载中涉及到的中文乱码\"></a>3.4 文件的上传和下载中涉及到的中文乱码</h3><p>Web中的文件操作主要是上传和下载，这个过程也是依托于Http协议作为数据载体。所以，最终是否乱码重点在于是否正确的设置http的request、response的header中的相关字段。如ContentType、Content-Disposition的设定等。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class=\"line\">response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class=\"line\">response.setContentType(&quot;application/x-msdownload&quot;);</span><br><span class=\"line\">response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是<strong>Content-Disposition</strong>的filename属性值，如果fileName含有中文，那么要格外注意fileName字符串的编码格式。在<a href=\"https://tools.ietf.org/html/rfc5987\">rfc5987</a>对于HTTP的Header中参数的编码做出了明确的规定：</p>\n<blockquote>\n<p>By default, message header field parameters in Hypertext Transfer  Protocol (HTTP) messages cannot carry characters outside the ISO-8859-1 character set.</p>\n</blockquote>\n<p>也就是说默认情况下，Http的Header中的参数只能用ISO-8859-1字符集中的字符，那么是否意味着Content-Disposition中的fileName字符串也要转成ISO-8859-1了呢？答案是：NO！原因如下：Content-Disposition其实不属于Http/1.1标准。这在<a href=\"https://tools.ietf.org/html/rfc2616#section-15.5\">RFC2616</a>中有明确的说明。只因为其使用广泛，HTTP才对其支持。在<a href=\"https://tools.ietf.org/html/rfc6266#section-4.3\">rfc6266</a>中也详细介绍了Content-Disposition的filename参数含义和用法。下面是对于下载包含中文名称的文件时的解决方案。</p>\n<h6 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h6><p>最简单就是直接用ISO8859-1对文件名进行编码，大多数浏览器都支持。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exportFileName.getBytes(&quot;UTF-8&quot;),&quot;ISO8859-1&quot;);//这里的UTF-8也可能是别的编码，主要依据系统默认的编码来设定。</span><br></pre></td></tr></table></figure>\n<p>或通过其它编码，如UTF-8。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.addHeader(&quot;Content-Disposition&quot;,</span><br><span class=\"line\">                &quot;attachment; filename*=UTF-8&#x27;&#x27;&quot; + URLEncoder.encode(exportFileName, &quot;UTF8&quot;));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h2><p>编解码问题是多语言交互系统中必然要面对的问题，尤其对于中文环境中的开发者来说，在入门阶段或多或少都会遇到此类问题。乱码问题本质就是通信双方使用的标准不一致。所以，解决乱码问题的方法其实也很简单，统一下编解码标准即可。此外，深入理解各种编码标准的原理和关系也非常重要，在以后遇到类似问题的时候能够更加准确的判断出造成乱码的原因。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckx4dc2k20000k60jam42ejf7","category_id":"ckx4fo2em0004cw0j7eie3e9g","_id":"ckx4fo2eo0005cw0jceeqhg6a"},{"post_id":"ckx4dc2k20000k60jam42ejf7","category_id":"ckx4fpb8f0000x30jc1uwhzpa","_id":"ckx4fpb8o0001x30j18pr5xrg"}],"PostTag":[{"post_id":"ckx4dc2k20000k60jam42ejf7","tag_id":"ckx4fncr30001cw0jfhq33fai","_id":"ckx4fncr60003cw0jdnxie2wd"}],"Tag":[{"name":"Java","_id":"ckx4fncqx0000cw0j593d3gfg"},{"name":"ThreadLocal","_id":"ckx4fncr30001cw0jfhq33fai"}]}}